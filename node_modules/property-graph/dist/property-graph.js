class t{constructor(){this._listeners={}}addEventListener(t,e){const s=this._listeners;return void 0===s[t]&&(s[t]=[]),-1===s[t].indexOf(e)&&s[t].push(e),this}removeEventListener(t,e){if(void 0===this._listeners)return this;const s=this._listeners[t];if(void 0!==s){const t=s.indexOf(e);-1!==t&&s.splice(t,1)}return this}dispatchEvent(t){if(void 0===this._listeners)return this;const e=this._listeners[t.type];if(void 0!==e){const s=e.slice(0);for(let e=0,i=s.length;e<i;e++)s[e].call(this,t)}return this}dispose(){for(const t in this._listeners)delete this._listeners[t]}}class e extends t{constructor(t,e,s,i){if(void 0===i&&(i={}),super(),this._name=void 0,this._parent=void 0,this._child=void 0,this._attributes=void 0,this._disposed=!1,this._name=t,this._parent=e,this._child=s,this._attributes=i,!e.isOnGraph(s))throw new Error("Cannot connect disconnected graphs.")}getName(){return this._name}getParent(){return this._parent}getChild(){return this._child}setChild(t){return this._child=t,this}getAttributes(){return this._attributes}dispose(){this._disposed||(this._disposed=!0,this.dispatchEvent({type:"dispose",target:this}),super.dispose())}isDisposed(){return this._disposed}}function s(t){return t instanceof e}function i(t){return Array.isArray(t)&&t[0]instanceof e}function r(t){return!!(t&&"object"==typeof t&&Object.values(t)[0]instanceof e)}const h=Symbol("attributes"),n=Symbol("immutableKeys");class d extends t{constructor(t){super(),this._disposed=!1,this.graph=void 0,this[h]=void 0,this[n]=void 0,this.graph=t,this[n]=new Set,this[h]=this._createAttributes()}getDefaults(){return{}}_createAttributes(){const t=this.getDefaults(),e={};for(const s in t){const i=t[s];if(i instanceof d){const t=this.graph.createEdge(s,this,i);t.addEventListener("dispose",()=>i.dispose()),this[n].add(s),e[s]=t}else e[s]=i}return e}isOnGraph(t){return this.graph===t.graph}isDisposed(){return this._disposed}dispose(){this._disposed||(this.graph.listChildEdges(this).forEach(t=>t.dispose()),this.graph.disconnectParents(this),this._disposed=!0,this.dispatchEvent({type:"dispose"}))}detach(){return this.graph.disconnectParents(this),this}swap(t,e){for(const n in this[h]){const d=this[h][n];if(s(d)){const s=d;s.getChild()===t&&this.setRef(n,e,s.getAttributes())}else if(i(d)){const s=d.find(e=>e.getChild()===t);if(s){const i=s.getAttributes();this.removeRef(n,t).addRef(n,e,i)}}else if(r(d)){const s=d;for(const i in s){const r=s[i];r.getChild()===t&&this.setRefMap(n,i,e,r.getAttributes())}}}return this}get(t){return this[h][t]}set(t,e){return this[h][t]=e,this.dispatchEvent({type:"change",attribute:t})}getRef(t){const e=this[h][t];return e?e.getChild():null}setRef(t,e,s){if(this[n].has(t))throw new Error('Cannot overwrite immutable attribute, "'+t+'".');const i=this[h][t];if(i&&i.dispose(),!e)return this;const r=this.graph.createEdge(t,this,e,s);return r.addEventListener("dispose",()=>{delete this[h][t],this.dispatchEvent({type:"change",attribute:t})}),this[h][t]=r,this.dispatchEvent({type:"change",attribute:t})}listRefs(t){return this[h][t].map(t=>t.getChild())}addRef(t,e,s){const i=this.graph.createEdge(t,this,e,s),r=this[h][t];return r.push(i),i.addEventListener("dispose",()=>{const e=r.filter(t=>t!==i);r.length=0;for(const t of e)r.push(t);this.dispatchEvent({type:"change",attribute:t})}),this.dispatchEvent({type:"change",attribute:t})}removeRef(t,e){return this[h][t].filter(t=>t.getChild()===e).forEach(t=>t.dispose()),this}listRefMapKeys(t){return Object.keys(this[h][t])}listRefMapValues(t){return Object.values(this[h][t]).map(t=>t.getChild())}getRefMap(t,e){const s=this[h][t];return s[e]?s[e].getChild():null}setRefMap(t,e,s,i){const r=this[h][t],n=r[e];if(n&&n.dispose(),!s)return this;i=Object.assign(i||{},{key:e});const d=this.graph.createEdge(t,this,s,{...i,key:e});return d.addEventListener("dispose",()=>{delete r[e],this.dispatchEvent({type:"change",attribute:t,key:e})}),r[e]=d,this.dispatchEvent({type:"change",attribute:t,key:e})}dispatchEvent(t){return super.dispatchEvent({...t,target:this}),this.graph.dispatchEvent({...t,target:this,type:"node:"+t.type}),this}}exports.$attributes=h,exports.$immutableKeys=n,exports.EventDispatcher=t,exports.Graph=class extends t{constructor(){super(...arguments),this._emptySet=new Set,this._edges=new Set,this._parentEdges=new Map,this._childEdges=new Map}listEdges(){return Array.from(this._edges)}listParentEdges(t){return Array.from(this._childEdges.get(t)||this._emptySet)}listParents(t){return this.listParentEdges(t).map(t=>t.getParent())}listChildEdges(t){return Array.from(this._parentEdges.get(t)||this._emptySet)}listChildren(t){return this.listChildEdges(t).map(t=>t.getChild())}disconnectParents(t,e){let s=this.listParentEdges(t);return e&&(s=s.filter(t=>e(t.getParent()))),s.forEach(t=>t.dispose()),this}createEdge(t,s,i,r){return this._registerEdge(new e(t,s,i,r))}_registerEdge(t){this._edges.add(t);const e=t.getParent();this._parentEdges.has(e)||this._parentEdges.set(e,new Set),this._parentEdges.get(e).add(t);const s=t.getChild();return this._childEdges.has(s)||this._childEdges.set(s,new Set),this._childEdges.get(s).add(t),t.addEventListener("dispose",()=>this._removeEdge(t)),t}_removeEdge(t){return this._edges.delete(t),this._parentEdges.get(t.getParent()).delete(t),this._childEdges.get(t.getChild()).delete(t),this}},exports.GraphEdge=e,exports.GraphNode=d,exports.isRef=s,exports.isRefList=i,exports.isRefMap=r;
//# sourceMappingURL=property-graph.js.map
