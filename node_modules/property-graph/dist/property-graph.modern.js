class t{constructor(){this._listeners={}}addEventListener(t,e){const s=this._listeners;return void 0===s[t]&&(s[t]=[]),-1===s[t].indexOf(e)&&s[t].push(e),this}removeEventListener(t,e){if(void 0===this._listeners)return this;const s=this._listeners[t];if(void 0!==s){const t=s.indexOf(e);-1!==t&&s.splice(t,1)}return this}dispatchEvent(t){if(void 0===this._listeners)return this;const e=this._listeners[t.type];if(void 0!==e){const s=e.slice(0);for(let e=0,i=s.length;e<i;e++)s[e].call(this,t)}return this}dispose(){for(const t in this._listeners)delete this._listeners[t]}}class e extends t{constructor(t,e,s,i={}){if(super(),this._name=void 0,this._parent=void 0,this._child=void 0,this._attributes=void 0,this._disposed=!1,this._name=t,this._parent=e,this._child=s,this._attributes=i,!e.isOnGraph(s))throw new Error("Cannot connect disconnected graphs.")}getName(){return this._name}getParent(){return this._parent}getChild(){return this._child}setChild(t){return this._child=t,this}getAttributes(){return this._attributes}dispose(){this._disposed||(this._disposed=!0,this.dispatchEvent({type:"dispose",target:this}),super.dispose())}isDisposed(){return this._disposed}}class s extends t{constructor(...t){super(...t),this._emptySet=new Set,this._edges=new Set,this._parentEdges=new Map,this._childEdges=new Map}listEdges(){return Array.from(this._edges)}listParentEdges(t){return Array.from(this._childEdges.get(t)||this._emptySet)}listParents(t){return this.listParentEdges(t).map(t=>t.getParent())}listChildEdges(t){return Array.from(this._parentEdges.get(t)||this._emptySet)}listChildren(t){return this.listChildEdges(t).map(t=>t.getChild())}disconnectParents(t,e){let s=this.listParentEdges(t);return e&&(s=s.filter(t=>e(t.getParent()))),s.forEach(t=>t.dispose()),this}createEdge(t,s,i,r){return this._registerEdge(new e(t,s,i,r))}_registerEdge(t){this._edges.add(t);const e=t.getParent();this._parentEdges.has(e)||this._parentEdges.set(e,new Set),this._parentEdges.get(e).add(t);const s=t.getChild();return this._childEdges.has(s)||this._childEdges.set(s,new Set),this._childEdges.get(s).add(t),t.addEventListener("dispose",()=>this._removeEdge(t)),t}_removeEdge(t){return this._edges.delete(t),this._parentEdges.get(t.getParent()).delete(t),this._childEdges.get(t.getChild()).delete(t),this}}function i(){return i=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var s=arguments[e];for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&(t[i]=s[i])}return t},i.apply(this,arguments)}function r(t){return t instanceof e}function n(t){return Array.isArray(t)&&t[0]instanceof e}function h(t){return!!(t&&"object"==typeof t&&Object.values(t)[0]instanceof e)}const d=Symbol("attributes"),a=Symbol("immutableKeys");class o extends t{constructor(t){super(),this._disposed=!1,this.graph=void 0,this[d]=void 0,this[a]=void 0,this.graph=t,this[a]=new Set,this[d]=this._createAttributes()}getDefaults(){return{}}_createAttributes(){const t=this.getDefaults(),e={};for(const s in t){const i=t[s];if(i instanceof o){const t=this.graph.createEdge(s,this,i);t.addEventListener("dispose",()=>i.dispose()),this[a].add(s),e[s]=t}else e[s]=i}return e}isOnGraph(t){return this.graph===t.graph}isDisposed(){return this._disposed}dispose(){this._disposed||(this.graph.listChildEdges(this).forEach(t=>t.dispose()),this.graph.disconnectParents(this),this._disposed=!0,this.dispatchEvent({type:"dispose"}))}detach(){return this.graph.disconnectParents(this),this}swap(t,e){for(const s in this[d]){const i=this[d][s];if(r(i)){const r=i;r.getChild()===t&&this.setRef(s,e,r.getAttributes())}else if(n(i)){const r=i.find(e=>e.getChild()===t);if(r){const i=r.getAttributes();this.removeRef(s,t).addRef(s,e,i)}}else if(h(i)){const r=i;for(const i in r){const n=r[i];n.getChild()===t&&this.setRefMap(s,i,e,n.getAttributes())}}}return this}get(t){return this[d][t]}set(t,e){return this[d][t]=e,this.dispatchEvent({type:"change",attribute:t})}getRef(t){const e=this[d][t];return e?e.getChild():null}setRef(t,e,s){if(this[a].has(t))throw new Error(`Cannot overwrite immutable attribute, "${t}".`);const i=this[d][t];if(i&&i.dispose(),!e)return this;const r=this.graph.createEdge(t,this,e,s);return r.addEventListener("dispose",()=>{delete this[d][t],this.dispatchEvent({type:"change",attribute:t})}),this[d][t]=r,this.dispatchEvent({type:"change",attribute:t})}listRefs(t){return this[d][t].map(t=>t.getChild())}addRef(t,e,s){const i=this.graph.createEdge(t,this,e,s),r=this[d][t];return r.push(i),i.addEventListener("dispose",()=>{const e=r.filter(t=>t!==i);r.length=0;for(const t of e)r.push(t);this.dispatchEvent({type:"change",attribute:t})}),this.dispatchEvent({type:"change",attribute:t})}removeRef(t,e){return this[d][t].filter(t=>t.getChild()===e).forEach(t=>t.dispose()),this}listRefMapKeys(t){return Object.keys(this[d][t])}listRefMapValues(t){return Object.values(this[d][t]).map(t=>t.getChild())}getRefMap(t,e){const s=this[d][t];return s[e]?s[e].getChild():null}setRefMap(t,e,s,r){const n=this[d][t],h=n[e];if(h&&h.dispose(),!s)return this;r=Object.assign(r||{},{key:e});const a=this.graph.createEdge(t,this,s,i({},r,{key:e}));return a.addEventListener("dispose",()=>{delete n[e],this.dispatchEvent({type:"change",attribute:t,key:e})}),n[e]=a,this.dispatchEvent({type:"change",attribute:t,key:e})}dispatchEvent(t){return super.dispatchEvent(i({},t,{target:this})),this.graph.dispatchEvent(i({},t,{target:this,type:`node:${t.type}`})),this}}export{d as $attributes,a as $immutableKeys,t as EventDispatcher,s as Graph,e as GraphEdge,o as GraphNode,r as isRef,n as isRefList,h as isRefMap};
//# sourceMappingURL=property-graph.modern.js.map
