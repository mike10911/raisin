{"version":3,"file":"property-graph.modern.js","sources":["../src/event-dispatcher.ts","../src/graph-edge.ts","../src/graph.ts","../src/utils.ts","../src/graph-node.ts"],"sourcesContent":["import type { Graph } from './graph';\nimport type { GraphNode } from './graph-node';\nimport type { GraphEdge } from './graph-edge';\n\nexport interface BaseEvent {\n\ttype: string;\n\t[attachment: string]: unknown;\n}\n\nexport interface GraphEvent extends BaseEvent {\n\ttarget: Graph<GraphNode>;\n}\n\nexport interface GraphNodeEvent extends BaseEvent {\n\ttarget: GraphNode;\n}\n\nexport interface GraphEdgeEvent extends BaseEvent {\n\ttarget: GraphEdge<GraphNode, GraphNode>;\n}\n\nexport type EventListener<E> = (event: E) => void;\n\nexport class EventDispatcher<T extends BaseEvent> {\n\tprivate _listeners = {} as Record<string, EventListener<T>[]>;\n\n\taddEventListener(type: string, listener: EventListener<T>): this {\n\t\tconst listeners = this._listeners;\n\n\t\tif (listeners[type] === undefined) {\n\t\t\tlisteners[type] = [] as EventListener<T>[];\n\t\t}\n\n\t\tif (listeners[type].indexOf(listener) === -1) {\n\t\t\tlisteners[type].push(listener);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tremoveEventListener(type: string, listener: EventListener<T>): this {\n\t\tif (this._listeners === undefined) return this;\n\n\t\tconst listeners = this._listeners;\n\t\tconst listenerArray = listeners[type];\n\n\t\tif (listenerArray !== undefined) {\n\t\t\tconst index = listenerArray.indexOf(listener);\n\n\t\t\tif (index !== -1) {\n\t\t\t\tlistenerArray.splice(index, 1);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tdispatchEvent(event: T): this {\n\t\tif (this._listeners === undefined) return this;\n\n\t\tconst listeners = this._listeners;\n\t\tconst listenerArray = listeners[event.type];\n\n\t\tif (listenerArray !== undefined) {\n\t\t\t// Make a copy, in case listeners are removed while iterating.\n\t\t\tconst array = listenerArray.slice(0);\n\n\t\t\tfor (let i = 0, l = array.length; i < l; i++) {\n\t\t\t\tarray[i].call(this, event as T);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tdispose(): void {\n\t\tfor (const key in this._listeners) {\n\t\t\tdelete this._listeners[key];\n\t\t}\n\t}\n}\n","import { EventDispatcher, GraphEdgeEvent } from './event-dispatcher';\nimport { GraphNode } from './graph-node';\n\n/**\n * Represents a connection between two {@link GraphNode} resources in a {@link Graph}.\n *\n * The left node is considered the owner, and the right node the resource. The\n * owner is responsible for being able find and remove a reference to a resource, given\n * that link. The resource does not hold a reference to the link or to the owner,\n * although that reverse lookup can be done on the graph.\n *\n * @category Graph\n */\nexport class GraphEdge<Parent extends GraphNode, Child extends GraphNode> extends EventDispatcher<GraphEdgeEvent> {\n\tprivate _disposed = false;\n\n\tconstructor(\n\t\tprivate readonly _name: string,\n\t\tprivate readonly _parent: Parent,\n\t\tprivate _child: Child,\n\t\tprivate _attributes: Record<string, unknown> = {}\n\t) {\n\t\tsuper();\n\t\tif (!_parent.isOnGraph(_child)) {\n\t\t\tthrow new Error('Cannot connect disconnected graphs.');\n\t\t}\n\t}\n\n\t/** Name. */\n\tgetName(): string {\n\t\treturn this._name;\n\t}\n\n\t/** Owner node. */\n\tgetParent(): Parent {\n\t\treturn this._parent;\n\t}\n\n\t/** Resource node. */\n\tgetChild(): Child {\n\t\treturn this._child;\n\t}\n\n\t/**\n\t * Sets the child node.\n\t *\n\t * @internal Only {@link Graph} implementations may safely call this method directly. Use\n\t * \t{@link Property.swap} or {@link Graph.swapChild} instead.\n\t */\n\tsetChild(child: Child): this {\n\t\tthis._child = child;\n\t\treturn this;\n\t}\n\n\t/** Attributes of the graph node relationship. */\n\tgetAttributes(): Record<string, unknown> {\n\t\treturn this._attributes;\n\t}\n\n\t/** Destroys a (currently intact) edge, updating both the graph and the owner. */\n\tdispose(): void {\n\t\tif (this._disposed) return;\n\t\tthis._disposed = true;\n\t\tthis.dispatchEvent({ type: 'dispose', target: this });\n\t\tsuper.dispose();\n\t}\n\n\t/** Whether this link has been destroyed. */\n\tisDisposed(): boolean {\n\t\treturn this._disposed;\n\t}\n}\n","import { GraphNodeEvent } from '.';\nimport { EventDispatcher, GraphEdgeEvent, GraphEvent } from './event-dispatcher';\nimport { GraphEdge } from './graph-edge';\nimport { GraphNode } from './graph-node';\n\n/**\n * A graph manages a network of {@link GraphNode} nodes, connected\n * by {@link @Link} edges.\n *\n * @category Graph\n */\nexport class Graph<T extends GraphNode> extends EventDispatcher<GraphEvent | GraphNodeEvent | GraphEdgeEvent> {\n\tprivate _emptySet: Set<GraphEdge<T, T>> = new Set();\n\n\tprivate _edges: Set<GraphEdge<T, T>> = new Set();\n\tprivate _parentEdges: Map<T, Set<GraphEdge<T, T>>> = new Map();\n\tprivate _childEdges: Map<T, Set<GraphEdge<T, T>>> = new Map();\n\n\t/** Returns a list of all parent->child edges on this graph. */\n\tpublic listEdges(): GraphEdge<T, T>[] {\n\t\treturn Array.from(this._edges);\n\t}\n\n\t/** Returns a list of all edges on the graph having the given node as their child. */\n\tpublic listParentEdges(node: T): GraphEdge<T, T>[] {\n\t\treturn Array.from(this._childEdges.get(node) || this._emptySet);\n\t}\n\n\t/** Returns a list of parent nodes for the given child node. */\n\tpublic listParents(node: T): T[] {\n\t\treturn this.listParentEdges(node).map((edge) => edge.getParent());\n\t}\n\n\t/** Returns a list of all edges on the graph having the given node as their parent. */\n\tpublic listChildEdges(node: T): GraphEdge<T, T>[] {\n\t\treturn Array.from(this._parentEdges.get(node) || this._emptySet);\n\t}\n\n\t/** Returns a list of child nodes for the given parent node. */\n\tpublic listChildren(node: T): T[] {\n\t\treturn this.listChildEdges(node).map((edge) => edge.getChild());\n\t}\n\n\tpublic disconnectParents(node: T, filter?: (n: T) => boolean): this {\n\t\tlet edges = this.listParentEdges(node);\n\t\tif (filter) {\n\t\t\tedges = edges.filter((edge) => filter(edge.getParent()));\n\t\t}\n\t\tedges.forEach((edge) => edge.dispose());\n\t\treturn this;\n\t}\n\n\t/**\n\t * Creates a {@link GraphEdge} connecting two {@link GraphNode} instances. Edge is returned\n\t * for the caller to store.\n\t * @param a Owner\n\t * @param b Resource\n\t */\n\tpublic createEdge<A extends T, B extends T>(\n\t\tname: string,\n\t\ta: A,\n\t\tb: B,\n\t\tattributes?: Record<string, unknown>\n\t): GraphEdge<A, B> {\n\t\treturn this._registerEdge(new GraphEdge(name, a, b, attributes)) as GraphEdge<A, B>;\n\t}\n\n\t/**********************************************************************************************\n\t * Internal.\n\t */\n\n\tprivate _registerEdge(edge: GraphEdge<T, T>): GraphEdge<T, T> {\n\t\tthis._edges.add(edge);\n\n\t\tconst parent = edge.getParent();\n\t\tif (!this._parentEdges.has(parent)) this._parentEdges.set(parent, new Set());\n\t\tthis._parentEdges.get(parent)!.add(edge);\n\n\t\tconst child = edge.getChild();\n\t\tif (!this._childEdges.has(child)) this._childEdges.set(child, new Set());\n\t\tthis._childEdges.get(child)!.add(edge);\n\n\t\tedge.addEventListener('dispose', () => this._removeEdge(edge));\n\t\treturn edge;\n\t}\n\n\t/**\n\t * Removes the {@link GraphEdge} from the {@link Graph}. This method should only\n\t * be invoked by the onDispose() listener created in {@link _registerEdge()}. The\n\t * public method of removing an edge is {@link GraphEdge.dispose}.\n\t */\n\tprivate _removeEdge(edge: GraphEdge<T, T>): this {\n\t\tthis._edges.delete(edge);\n\t\tthis._parentEdges.get(edge.getParent())!.delete(edge);\n\t\tthis._childEdges.get(edge.getChild())!.delete(edge);\n\t\treturn this;\n\t}\n}\n","import type { Ref, RefMap } from './constants';\nimport { GraphEdge } from './graph-edge';\n\nexport function isRef(value: Ref | unknown): boolean {\n\treturn value instanceof GraphEdge;\n}\n\nexport function isRefList(value: Ref[] | unknown): boolean {\n\treturn Array.isArray(value) && value[0] instanceof GraphEdge;\n}\n\nexport function isRefMap(value: RefMap | unknown): boolean {\n\treturn !!(value && typeof value === 'object' && Object.values(value)[0] instanceof GraphEdge);\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/ban-types */\nimport { GraphNodeEvent } from '.';\nimport { LiteralKeys, Nullable, Ref, RefMap, RefKeys, RefListKeys, RefMapKeys } from './constants';\nimport { BaseEvent, EventDispatcher } from './event-dispatcher';\nimport { Graph } from './graph';\nimport { GraphEdge } from './graph-edge';\nimport { isRef, isRefList, isRefMap } from './utils';\n\n// References:\n// - https://stackoverflow.com/a/70163679/1314762\n// - https://stackoverflow.com/a/70201805/1314762\n\ntype GraphNodeAttributesInternal<Parent extends GraphNode, Attributes extends {}> = {\n\t[Key in keyof Attributes]: Attributes[Key] extends GraphNode\n\t\t? GraphEdge<Parent, Attributes[Key]>\n\t\t: Attributes[Key] extends GraphNode[]\n\t\t? GraphEdge<Parent, Attributes[Key][number]>[]\n\t\t: Attributes[Key] extends { [key: string]: GraphNode }\n\t\t? Record<string, GraphEdge<Parent, Attributes[Key][string]>>\n\t\t: Attributes[Key];\n};\n\nexport const $attributes = Symbol('attributes');\nexport const $immutableKeys = Symbol('immutableKeys');\n\n/**\n * Represents a node in a {@link Graph}.\n *\n * @category Graph\n */\nexport abstract class GraphNode<Attributes extends {} = {}> extends EventDispatcher<GraphNodeEvent> {\n\tprivate _disposed = false;\n\n\t/**\n\t * Internal graph used to search and maintain references.\n\t * @hidden\n\t */\n\tprotected readonly graph: Graph<GraphNode>;\n\n\t/**\n\t * Attributes (literal values and GraphNode references) associated with this instance. For each\n\t * GraphNode reference, the attributes stores a {@link GraphEdge}. List and Map references are\n\t * stored as arrays and dictionaries of edges.\n\t * @internal\n\t */\n\tprotected readonly [$attributes]: GraphNodeAttributesInternal<this, Attributes>;\n\n\t/**\n\t * Attributes included with `getDefaultAttributes` are considered immutable, and cannot be\n\t * modifed by `.setRef()`, `.copy()`, or other GraphNode methods. Both the edges and the\n\t * properties will be disposed with the parent GraphNode.\n\t *\n\t * Currently, only single-edge references (getRef/setRef) are supported as immutables.\n\t *\n\t * @internal\n\t */\n\tprotected readonly [$immutableKeys]: Set<string>;\n\n\tconstructor(graph: Graph<GraphNode>) {\n\t\tsuper();\n\t\tthis.graph = graph;\n\t\tthis[$immutableKeys] = new Set();\n\t\tthis[$attributes] = this._createAttributes();\n\t}\n\n\t/**\n\t * Returns default attributes for the graph node. Subclasses having any attributes (either\n\t * literal values or references to other graph nodes) must override this method. Literal\n\t * attributes should be given their default values, if any. References should generally be\n\t * initialized as empty (Ref → null, RefList → [], RefMap → {}) and then modified by setters.\n\t *\n\t * Any single-edge references (setRef) returned by this method will be considered immutable,\n\t * to be owned by and disposed with the parent node. Multi-edge references (addRef, removeRef,\n\t * setRefMap) cannot be returned as default attributes.\n\t */\n\tprotected getDefaults(): Nullable<Attributes> {\n\t\treturn {} as Nullable<Attributes>;\n\t}\n\n\t/**\n\t * Constructs and returns an object used to store a graph nodes attributes. Compared to the\n\t * default Attributes interface, this has two distinctions:\n\t *\n\t * 1. Slots for GraphNode<T> objects are replaced with slots for GraphEdge<this, GraphNode<T>>\n\t * 2. GraphNode<T> objects provided as defaults are considered immutable\n\t *\n\t * @internal\n\t */\n\tprivate _createAttributes(): GraphNodeAttributesInternal<this, Attributes> {\n\t\tconst defaultAttributes = this.getDefaults();\n\t\tconst attributes = {} as GraphNodeAttributesInternal<this, Attributes>;\n\t\tfor (const key in defaultAttributes) {\n\t\t\tconst value = defaultAttributes[key] as any;\n\t\t\tif (value instanceof GraphNode) {\n\t\t\t\tconst ref = this.graph.createEdge(key, this, value);\n\t\t\t\tref.addEventListener('dispose', () => value.dispose());\n\t\t\t\tthis[$immutableKeys].add(key);\n\t\t\t\tattributes[key] = ref as any;\n\t\t\t} else {\n\t\t\t\tattributes[key] = value as any;\n\t\t\t}\n\t\t}\n\t\treturn attributes;\n\t}\n\n\t/** @internal Returns true if two nodes are on the same {@link Graph}. */\n\tpublic isOnGraph(other: GraphNode): boolean {\n\t\treturn this.graph === other.graph;\n\t}\n\n\t/** Returns true if the node has been permanently removed from the graph. */\n\tpublic isDisposed(): boolean {\n\t\treturn this._disposed;\n\t}\n\n\t/**\n\t * Removes both inbound references to and outbound references from this object. At the end\n\t * of the process the object holds no references, and nothing holds references to it. A\n\t * disposed object is not reusable.\n\t */\n\tpublic dispose(): void {\n\t\tif (this._disposed) return;\n\t\tthis.graph.listChildEdges(this).forEach((edge) => edge.dispose());\n\t\tthis.graph.disconnectParents(this);\n\t\tthis._disposed = true;\n\t\tthis.dispatchEvent({ type: 'dispose' });\n\t}\n\n\t/**\n\t * Removes all inbound references to this object. At the end of the process the object is\n\t * considered 'detached': it may hold references to child resources, but nothing holds\n\t * references to it. A detached object may be re-attached.\n\t */\n\tpublic detach(): this {\n\t\tthis.graph.disconnectParents(this);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Transfers this object's references from the old node to the new one. The old node is fully\n\t * detached from this parent at the end of the process.\n\t *\n\t * @hidden This method works imperfectly with Root, Scene, and Node properties, which may\n\t * already hold equivalent references to the replacement object.\n\t */\n\tpublic swap(old: GraphNode, replacement: GraphNode): this {\n\t\tfor (const attribute in this[$attributes]) {\n\t\t\tconst value = this[$attributes][attribute] as Ref | Ref[] | RefMap;\n\t\t\tif (isRef(value)) {\n\t\t\t\tconst ref = value as Ref;\n\t\t\t\tif (ref.getChild() === old) {\n\t\t\t\t\tthis.setRef(attribute as any, replacement, ref.getAttributes());\n\t\t\t\t}\n\t\t\t} else if (isRefList(value)) {\n\t\t\t\tconst refs = value as Ref[];\n\t\t\t\tconst ref = refs.find((ref) => ref.getChild() === old);\n\t\t\t\tif (ref) {\n\t\t\t\t\tconst refAttributes = ref.getAttributes();\n\t\t\t\t\tthis.removeRef(attribute as any, old).addRef(attribute as any, replacement, refAttributes);\n\t\t\t\t}\n\t\t\t} else if (isRefMap(value)) {\n\t\t\t\tconst refMap = value as RefMap;\n\t\t\t\tfor (const key in refMap) {\n\t\t\t\t\tconst ref = refMap[key];\n\t\t\t\t\tif (ref.getChild() === old) {\n\t\t\t\t\t\tthis.setRefMap(attribute as any, key, replacement, ref.getAttributes());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Literal attributes.\n\t */\n\n\t/** @hidden */\n\tprotected get<K extends LiteralKeys<Attributes>>(attribute: K): Attributes[K] {\n\t\treturn this[$attributes][attribute] as Attributes[K];\n\t}\n\n\t/** @hidden */\n\tprotected set<K extends LiteralKeys<Attributes>>(attribute: K, value: Attributes[K]): this {\n\t\t(this[$attributes][attribute] as Attributes[K]) = value;\n\t\treturn this.dispatchEvent({ type: 'change', attribute });\n\t}\n\n\t/**********************************************************************************************\n\t * Ref: 1:1 graph node references.\n\t */\n\n\t/** @hidden */\n\tprotected getRef<K extends RefKeys<Attributes>>(attribute: K): (GraphNode & Attributes[K]) | null {\n\t\tconst ref = this[$attributes][attribute] as Ref;\n\t\treturn ref ? (ref.getChild() as GraphNode & Attributes[K]) : null;\n\t}\n\n\t/** @hidden */\n\tprotected setRef<K extends RefKeys<Attributes>>(\n\t\tattribute: K,\n\t\tvalue: (GraphNode & Attributes[K]) | null,\n\t\tattributes?: Record<string, unknown>\n\t): this {\n\t\tif (this[$immutableKeys].has(attribute as string)) {\n\t\t\tthrow new Error(`Cannot overwrite immutable attribute, \"${attribute}\".`);\n\t\t}\n\n\t\tconst prevRef = this[$attributes][attribute] as Ref;\n\t\tif (prevRef) prevRef.dispose(); // TODO(cleanup): Possible duplicate event.\n\n\t\tif (!value) return this;\n\n\t\tconst ref = this.graph.createEdge(attribute as string, this, value, attributes);\n\t\tref.addEventListener('dispose', () => {\n\t\t\tdelete this[$attributes][attribute];\n\t\t\tthis.dispatchEvent({ type: 'change', attribute });\n\t\t});\n\t\t(this[$attributes][attribute] as Ref) = ref;\n\n\t\treturn this.dispatchEvent({ type: 'change', attribute });\n\t}\n\n\t/**********************************************************************************************\n\t * RefList: 1:many graph node references.\n\t */\n\n\t/** @hidden */\n\tprotected listRefs<K extends RefListKeys<Attributes>>(attribute: K): GraphNode[] & Attributes[K] {\n\t\tconst refs = this[$attributes][attribute] as Ref[];\n\t\treturn refs.map((ref) => ref.getChild()) as GraphNode[] & Attributes[K];\n\t}\n\n\t/** @hidden */\n\tprotected addRef<K extends RefListKeys<Attributes>>(\n\t\tattribute: K,\n\t\tvalue: GraphNode & Attributes[K][keyof Attributes[K]],\n\t\tattributes?: Record<string, unknown>\n\t): this {\n\t\tconst ref = this.graph.createEdge(attribute as string, this, value, attributes);\n\n\t\tconst refs = this[$attributes][attribute] as Ref[];\n\t\trefs.push(ref);\n\n\t\tref.addEventListener('dispose', () => {\n\t\t\tconst retained = refs.filter((l) => l !== ref);\n\t\t\trefs.length = 0;\n\t\t\tfor (const retainedRef of retained) refs.push(retainedRef);\n\t\t\tthis.dispatchEvent({ type: 'change', attribute });\n\t\t});\n\n\t\treturn this.dispatchEvent({ type: 'change', attribute });\n\t}\n\n\t/** @hidden */\n\tprotected removeRef<K extends RefListKeys<Attributes>>(\n\t\tattribute: K,\n\t\tvalue: GraphNode & Attributes[K][keyof Attributes[K]]\n\t): this {\n\t\tconst refs = this[$attributes][attribute] as Ref[];\n\t\tconst pruned = refs.filter((ref) => ref.getChild() === value);\n\t\tpruned.forEach((ref) => ref.dispose()); // TODO(cleanup): Possible duplicate event.\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * RefMap: Named 1:many (map) graph node references.\n\t */\n\n\t/** @hidden */\n\tprotected listRefMapKeys<K extends RefMapKeys<Attributes>>(key: K): string[] {\n\t\treturn Object.keys(this[$attributes][key]);\n\t}\n\n\t/** @hidden */\n\tprotected listRefMapValues<K extends RefMapKeys<Attributes>>(\n\t\tkey: K\n\t): GraphNode[] & Attributes[K][keyof Attributes[K]][] {\n\t\treturn Object.values(this[$attributes][key]).map((ref: any) => ref.getChild());\n\t}\n\n\t/** @hidden */\n\tprotected getRefMap<K extends RefMapKeys<Attributes>, SK extends keyof Attributes[K]>(\n\t\tattribute: K,\n\t\tkey: SK\n\t): (GraphNode & Attributes[K][SK]) | null {\n\t\tconst refMap = this[$attributes][attribute] as any;\n\t\treturn refMap[key] ? refMap[key].getChild() : null;\n\t}\n\n\t/** @hidden */\n\tprotected setRefMap<K extends RefMapKeys<Attributes>, SK extends keyof Attributes[K]>(\n\t\tattribute: K,\n\t\tkey: SK,\n\t\tvalue: (GraphNode & Attributes[K][SK]) | null,\n\t\tmetadata?: Record<string, unknown>\n\t): this {\n\t\tconst refMap = this[$attributes][attribute] as any;\n\n\t\tconst prevRef = refMap[key];\n\t\tif (prevRef) prevRef.dispose(); // TODO(cleanup): Possible duplicate event.\n\n\t\tif (!value) return this;\n\n\t\tmetadata = Object.assign(metadata || {}, { key: key });\n\t\tconst ref = this.graph.createEdge(attribute as string, this, value, { ...metadata, key });\n\t\tref.addEventListener('dispose', () => {\n\t\t\tdelete refMap[key];\n\t\t\tthis.dispatchEvent({ type: 'change', attribute, key });\n\t\t});\n\t\trefMap[key] = ref;\n\n\t\treturn this.dispatchEvent({ type: 'change', attribute, key });\n\t}\n\n\t/**********************************************************************************************\n\t * Events.\n\t */\n\n\tdispatchEvent(event: BaseEvent): this {\n\t\tsuper.dispatchEvent({ ...event, target: this });\n\t\tthis.graph.dispatchEvent({ ...event, target: this, type: `node:${event.type}` });\n\t\treturn this;\n\t}\n}\n"],"names":["EventDispatcher","_listeners","addEventListener","type","listener","listeners","this","undefined","indexOf","push","removeEventListener","listenerArray","index","splice","dispatchEvent","event","array","slice","i","l","length","call","dispose","key","GraphEdge","constructor","_name","_parent","_child","_attributes","super","_disposed","isOnGraph","Error","getName","getParent","getChild","setChild","child","getAttributes","target","isDisposed","Graph","_emptySet","Set","_edges","_parentEdges","Map","_childEdges","listEdges","Array","from","listParentEdges","node","get","listParents","map","edge","listChildEdges","listChildren","disconnectParents","filter","edges","forEach","createEdge","name","a","b","attributes","_registerEdge","add","parent","has","set","_removeEdge","delete","isRef","value","isRefList","isArray","isRefMap","Object","values","$attributes","Symbol","$immutableKeys","GraphNode","graph","_createAttributes","getDefaults","defaultAttributes","ref","other","detach","swap","old","replacement","attribute","setRef","find","refAttributes","removeRef","addRef","refMap","setRefMap","getRef","prevRef","listRefs","refs","retained","retainedRef","listRefMapKeys","keys","listRefMapValues","getRefMap","metadata","assign"],"mappings":"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"}