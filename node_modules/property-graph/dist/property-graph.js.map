{"version":3,"file":"property-graph.js","sources":["../src/event-dispatcher.ts","../src/graph-edge.ts","../src/utils.ts","../src/graph-node.ts","../src/graph.ts"],"sourcesContent":["import type { Graph } from './graph';\nimport type { GraphNode } from './graph-node';\nimport type { GraphEdge } from './graph-edge';\n\nexport interface BaseEvent {\n\ttype: string;\n\t[attachment: string]: unknown;\n}\n\nexport interface GraphEvent extends BaseEvent {\n\ttarget: Graph<GraphNode>;\n}\n\nexport interface GraphNodeEvent extends BaseEvent {\n\ttarget: GraphNode;\n}\n\nexport interface GraphEdgeEvent extends BaseEvent {\n\ttarget: GraphEdge<GraphNode, GraphNode>;\n}\n\nexport type EventListener<E> = (event: E) => void;\n\nexport class EventDispatcher<T extends BaseEvent> {\n\tprivate _listeners = {} as Record<string, EventListener<T>[]>;\n\n\taddEventListener(type: string, listener: EventListener<T>): this {\n\t\tconst listeners = this._listeners;\n\n\t\tif (listeners[type] === undefined) {\n\t\t\tlisteners[type] = [] as EventListener<T>[];\n\t\t}\n\n\t\tif (listeners[type].indexOf(listener) === -1) {\n\t\t\tlisteners[type].push(listener);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tremoveEventListener(type: string, listener: EventListener<T>): this {\n\t\tif (this._listeners === undefined) return this;\n\n\t\tconst listeners = this._listeners;\n\t\tconst listenerArray = listeners[type];\n\n\t\tif (listenerArray !== undefined) {\n\t\t\tconst index = listenerArray.indexOf(listener);\n\n\t\t\tif (index !== -1) {\n\t\t\t\tlistenerArray.splice(index, 1);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tdispatchEvent(event: T): this {\n\t\tif (this._listeners === undefined) return this;\n\n\t\tconst listeners = this._listeners;\n\t\tconst listenerArray = listeners[event.type];\n\n\t\tif (listenerArray !== undefined) {\n\t\t\t// Make a copy, in case listeners are removed while iterating.\n\t\t\tconst array = listenerArray.slice(0);\n\n\t\t\tfor (let i = 0, l = array.length; i < l; i++) {\n\t\t\t\tarray[i].call(this, event as T);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tdispose(): void {\n\t\tfor (const key in this._listeners) {\n\t\t\tdelete this._listeners[key];\n\t\t}\n\t}\n}\n","import { EventDispatcher, GraphEdgeEvent } from './event-dispatcher';\nimport { GraphNode } from './graph-node';\n\n/**\n * Represents a connection between two {@link GraphNode} resources in a {@link Graph}.\n *\n * The left node is considered the owner, and the right node the resource. The\n * owner is responsible for being able find and remove a reference to a resource, given\n * that link. The resource does not hold a reference to the link or to the owner,\n * although that reverse lookup can be done on the graph.\n *\n * @category Graph\n */\nexport class GraphEdge<Parent extends GraphNode, Child extends GraphNode> extends EventDispatcher<GraphEdgeEvent> {\n\tprivate _disposed = false;\n\n\tconstructor(\n\t\tprivate readonly _name: string,\n\t\tprivate readonly _parent: Parent,\n\t\tprivate _child: Child,\n\t\tprivate _attributes: Record<string, unknown> = {}\n\t) {\n\t\tsuper();\n\t\tif (!_parent.isOnGraph(_child)) {\n\t\t\tthrow new Error('Cannot connect disconnected graphs.');\n\t\t}\n\t}\n\n\t/** Name. */\n\tgetName(): string {\n\t\treturn this._name;\n\t}\n\n\t/** Owner node. */\n\tgetParent(): Parent {\n\t\treturn this._parent;\n\t}\n\n\t/** Resource node. */\n\tgetChild(): Child {\n\t\treturn this._child;\n\t}\n\n\t/**\n\t * Sets the child node.\n\t *\n\t * @internal Only {@link Graph} implementations may safely call this method directly. Use\n\t * \t{@link Property.swap} or {@link Graph.swapChild} instead.\n\t */\n\tsetChild(child: Child): this {\n\t\tthis._child = child;\n\t\treturn this;\n\t}\n\n\t/** Attributes of the graph node relationship. */\n\tgetAttributes(): Record<string, unknown> {\n\t\treturn this._attributes;\n\t}\n\n\t/** Destroys a (currently intact) edge, updating both the graph and the owner. */\n\tdispose(): void {\n\t\tif (this._disposed) return;\n\t\tthis._disposed = true;\n\t\tthis.dispatchEvent({ type: 'dispose', target: this });\n\t\tsuper.dispose();\n\t}\n\n\t/** Whether this link has been destroyed. */\n\tisDisposed(): boolean {\n\t\treturn this._disposed;\n\t}\n}\n","import type { Ref, RefMap } from './constants';\nimport { GraphEdge } from './graph-edge';\n\nexport function isRef(value: Ref | unknown): boolean {\n\treturn value instanceof GraphEdge;\n}\n\nexport function isRefList(value: Ref[] | unknown): boolean {\n\treturn Array.isArray(value) && value[0] instanceof GraphEdge;\n}\n\nexport function isRefMap(value: RefMap | unknown): boolean {\n\treturn !!(value && typeof value === 'object' && Object.values(value)[0] instanceof GraphEdge);\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/ban-types */\nimport { GraphNodeEvent } from '.';\nimport { LiteralKeys, Nullable, Ref, RefMap, RefKeys, RefListKeys, RefMapKeys } from './constants';\nimport { BaseEvent, EventDispatcher } from './event-dispatcher';\nimport { Graph } from './graph';\nimport { GraphEdge } from './graph-edge';\nimport { isRef, isRefList, isRefMap } from './utils';\n\n// References:\n// - https://stackoverflow.com/a/70163679/1314762\n// - https://stackoverflow.com/a/70201805/1314762\n\ntype GraphNodeAttributesInternal<Parent extends GraphNode, Attributes extends {}> = {\n\t[Key in keyof Attributes]: Attributes[Key] extends GraphNode\n\t\t? GraphEdge<Parent, Attributes[Key]>\n\t\t: Attributes[Key] extends GraphNode[]\n\t\t? GraphEdge<Parent, Attributes[Key][number]>[]\n\t\t: Attributes[Key] extends { [key: string]: GraphNode }\n\t\t? Record<string, GraphEdge<Parent, Attributes[Key][string]>>\n\t\t: Attributes[Key];\n};\n\nexport const $attributes = Symbol('attributes');\nexport const $immutableKeys = Symbol('immutableKeys');\n\n/**\n * Represents a node in a {@link Graph}.\n *\n * @category Graph\n */\nexport abstract class GraphNode<Attributes extends {} = {}> extends EventDispatcher<GraphNodeEvent> {\n\tprivate _disposed = false;\n\n\t/**\n\t * Internal graph used to search and maintain references.\n\t * @hidden\n\t */\n\tprotected readonly graph: Graph<GraphNode>;\n\n\t/**\n\t * Attributes (literal values and GraphNode references) associated with this instance. For each\n\t * GraphNode reference, the attributes stores a {@link GraphEdge}. List and Map references are\n\t * stored as arrays and dictionaries of edges.\n\t * @internal\n\t */\n\tprotected readonly [$attributes]: GraphNodeAttributesInternal<this, Attributes>;\n\n\t/**\n\t * Attributes included with `getDefaultAttributes` are considered immutable, and cannot be\n\t * modifed by `.setRef()`, `.copy()`, or other GraphNode methods. Both the edges and the\n\t * properties will be disposed with the parent GraphNode.\n\t *\n\t * Currently, only single-edge references (getRef/setRef) are supported as immutables.\n\t *\n\t * @internal\n\t */\n\tprotected readonly [$immutableKeys]: Set<string>;\n\n\tconstructor(graph: Graph<GraphNode>) {\n\t\tsuper();\n\t\tthis.graph = graph;\n\t\tthis[$immutableKeys] = new Set();\n\t\tthis[$attributes] = this._createAttributes();\n\t}\n\n\t/**\n\t * Returns default attributes for the graph node. Subclasses having any attributes (either\n\t * literal values or references to other graph nodes) must override this method. Literal\n\t * attributes should be given their default values, if any. References should generally be\n\t * initialized as empty (Ref → null, RefList → [], RefMap → {}) and then modified by setters.\n\t *\n\t * Any single-edge references (setRef) returned by this method will be considered immutable,\n\t * to be owned by and disposed with the parent node. Multi-edge references (addRef, removeRef,\n\t * setRefMap) cannot be returned as default attributes.\n\t */\n\tprotected getDefaults(): Nullable<Attributes> {\n\t\treturn {} as Nullable<Attributes>;\n\t}\n\n\t/**\n\t * Constructs and returns an object used to store a graph nodes attributes. Compared to the\n\t * default Attributes interface, this has two distinctions:\n\t *\n\t * 1. Slots for GraphNode<T> objects are replaced with slots for GraphEdge<this, GraphNode<T>>\n\t * 2. GraphNode<T> objects provided as defaults are considered immutable\n\t *\n\t * @internal\n\t */\n\tprivate _createAttributes(): GraphNodeAttributesInternal<this, Attributes> {\n\t\tconst defaultAttributes = this.getDefaults();\n\t\tconst attributes = {} as GraphNodeAttributesInternal<this, Attributes>;\n\t\tfor (const key in defaultAttributes) {\n\t\t\tconst value = defaultAttributes[key] as any;\n\t\t\tif (value instanceof GraphNode) {\n\t\t\t\tconst ref = this.graph.createEdge(key, this, value);\n\t\t\t\tref.addEventListener('dispose', () => value.dispose());\n\t\t\t\tthis[$immutableKeys].add(key);\n\t\t\t\tattributes[key] = ref as any;\n\t\t\t} else {\n\t\t\t\tattributes[key] = value as any;\n\t\t\t}\n\t\t}\n\t\treturn attributes;\n\t}\n\n\t/** @internal Returns true if two nodes are on the same {@link Graph}. */\n\tpublic isOnGraph(other: GraphNode): boolean {\n\t\treturn this.graph === other.graph;\n\t}\n\n\t/** Returns true if the node has been permanently removed from the graph. */\n\tpublic isDisposed(): boolean {\n\t\treturn this._disposed;\n\t}\n\n\t/**\n\t * Removes both inbound references to and outbound references from this object. At the end\n\t * of the process the object holds no references, and nothing holds references to it. A\n\t * disposed object is not reusable.\n\t */\n\tpublic dispose(): void {\n\t\tif (this._disposed) return;\n\t\tthis.graph.listChildEdges(this).forEach((edge) => edge.dispose());\n\t\tthis.graph.disconnectParents(this);\n\t\tthis._disposed = true;\n\t\tthis.dispatchEvent({ type: 'dispose' });\n\t}\n\n\t/**\n\t * Removes all inbound references to this object. At the end of the process the object is\n\t * considered 'detached': it may hold references to child resources, but nothing holds\n\t * references to it. A detached object may be re-attached.\n\t */\n\tpublic detach(): this {\n\t\tthis.graph.disconnectParents(this);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Transfers this object's references from the old node to the new one. The old node is fully\n\t * detached from this parent at the end of the process.\n\t *\n\t * @hidden This method works imperfectly with Root, Scene, and Node properties, which may\n\t * already hold equivalent references to the replacement object.\n\t */\n\tpublic swap(old: GraphNode, replacement: GraphNode): this {\n\t\tfor (const attribute in this[$attributes]) {\n\t\t\tconst value = this[$attributes][attribute] as Ref | Ref[] | RefMap;\n\t\t\tif (isRef(value)) {\n\t\t\t\tconst ref = value as Ref;\n\t\t\t\tif (ref.getChild() === old) {\n\t\t\t\t\tthis.setRef(attribute as any, replacement, ref.getAttributes());\n\t\t\t\t}\n\t\t\t} else if (isRefList(value)) {\n\t\t\t\tconst refs = value as Ref[];\n\t\t\t\tconst ref = refs.find((ref) => ref.getChild() === old);\n\t\t\t\tif (ref) {\n\t\t\t\t\tconst refAttributes = ref.getAttributes();\n\t\t\t\t\tthis.removeRef(attribute as any, old).addRef(attribute as any, replacement, refAttributes);\n\t\t\t\t}\n\t\t\t} else if (isRefMap(value)) {\n\t\t\t\tconst refMap = value as RefMap;\n\t\t\t\tfor (const key in refMap) {\n\t\t\t\t\tconst ref = refMap[key];\n\t\t\t\t\tif (ref.getChild() === old) {\n\t\t\t\t\t\tthis.setRefMap(attribute as any, key, replacement, ref.getAttributes());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Literal attributes.\n\t */\n\n\t/** @hidden */\n\tprotected get<K extends LiteralKeys<Attributes>>(attribute: K): Attributes[K] {\n\t\treturn this[$attributes][attribute] as Attributes[K];\n\t}\n\n\t/** @hidden */\n\tprotected set<K extends LiteralKeys<Attributes>>(attribute: K, value: Attributes[K]): this {\n\t\t(this[$attributes][attribute] as Attributes[K]) = value;\n\t\treturn this.dispatchEvent({ type: 'change', attribute });\n\t}\n\n\t/**********************************************************************************************\n\t * Ref: 1:1 graph node references.\n\t */\n\n\t/** @hidden */\n\tprotected getRef<K extends RefKeys<Attributes>>(attribute: K): (GraphNode & Attributes[K]) | null {\n\t\tconst ref = this[$attributes][attribute] as Ref;\n\t\treturn ref ? (ref.getChild() as GraphNode & Attributes[K]) : null;\n\t}\n\n\t/** @hidden */\n\tprotected setRef<K extends RefKeys<Attributes>>(\n\t\tattribute: K,\n\t\tvalue: (GraphNode & Attributes[K]) | null,\n\t\tattributes?: Record<string, unknown>\n\t): this {\n\t\tif (this[$immutableKeys].has(attribute as string)) {\n\t\t\tthrow new Error(`Cannot overwrite immutable attribute, \"${attribute}\".`);\n\t\t}\n\n\t\tconst prevRef = this[$attributes][attribute] as Ref;\n\t\tif (prevRef) prevRef.dispose(); // TODO(cleanup): Possible duplicate event.\n\n\t\tif (!value) return this;\n\n\t\tconst ref = this.graph.createEdge(attribute as string, this, value, attributes);\n\t\tref.addEventListener('dispose', () => {\n\t\t\tdelete this[$attributes][attribute];\n\t\t\tthis.dispatchEvent({ type: 'change', attribute });\n\t\t});\n\t\t(this[$attributes][attribute] as Ref) = ref;\n\n\t\treturn this.dispatchEvent({ type: 'change', attribute });\n\t}\n\n\t/**********************************************************************************************\n\t * RefList: 1:many graph node references.\n\t */\n\n\t/** @hidden */\n\tprotected listRefs<K extends RefListKeys<Attributes>>(attribute: K): GraphNode[] & Attributes[K] {\n\t\tconst refs = this[$attributes][attribute] as Ref[];\n\t\treturn refs.map((ref) => ref.getChild()) as GraphNode[] & Attributes[K];\n\t}\n\n\t/** @hidden */\n\tprotected addRef<K extends RefListKeys<Attributes>>(\n\t\tattribute: K,\n\t\tvalue: GraphNode & Attributes[K][keyof Attributes[K]],\n\t\tattributes?: Record<string, unknown>\n\t): this {\n\t\tconst ref = this.graph.createEdge(attribute as string, this, value, attributes);\n\n\t\tconst refs = this[$attributes][attribute] as Ref[];\n\t\trefs.push(ref);\n\n\t\tref.addEventListener('dispose', () => {\n\t\t\tconst retained = refs.filter((l) => l !== ref);\n\t\t\trefs.length = 0;\n\t\t\tfor (const retainedRef of retained) refs.push(retainedRef);\n\t\t\tthis.dispatchEvent({ type: 'change', attribute });\n\t\t});\n\n\t\treturn this.dispatchEvent({ type: 'change', attribute });\n\t}\n\n\t/** @hidden */\n\tprotected removeRef<K extends RefListKeys<Attributes>>(\n\t\tattribute: K,\n\t\tvalue: GraphNode & Attributes[K][keyof Attributes[K]]\n\t): this {\n\t\tconst refs = this[$attributes][attribute] as Ref[];\n\t\tconst pruned = refs.filter((ref) => ref.getChild() === value);\n\t\tpruned.forEach((ref) => ref.dispose()); // TODO(cleanup): Possible duplicate event.\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * RefMap: Named 1:many (map) graph node references.\n\t */\n\n\t/** @hidden */\n\tprotected listRefMapKeys<K extends RefMapKeys<Attributes>>(key: K): string[] {\n\t\treturn Object.keys(this[$attributes][key]);\n\t}\n\n\t/** @hidden */\n\tprotected listRefMapValues<K extends RefMapKeys<Attributes>>(\n\t\tkey: K\n\t): GraphNode[] & Attributes[K][keyof Attributes[K]][] {\n\t\treturn Object.values(this[$attributes][key]).map((ref: any) => ref.getChild());\n\t}\n\n\t/** @hidden */\n\tprotected getRefMap<K extends RefMapKeys<Attributes>, SK extends keyof Attributes[K]>(\n\t\tattribute: K,\n\t\tkey: SK\n\t): (GraphNode & Attributes[K][SK]) | null {\n\t\tconst refMap = this[$attributes][attribute] as any;\n\t\treturn refMap[key] ? refMap[key].getChild() : null;\n\t}\n\n\t/** @hidden */\n\tprotected setRefMap<K extends RefMapKeys<Attributes>, SK extends keyof Attributes[K]>(\n\t\tattribute: K,\n\t\tkey: SK,\n\t\tvalue: (GraphNode & Attributes[K][SK]) | null,\n\t\tmetadata?: Record<string, unknown>\n\t): this {\n\t\tconst refMap = this[$attributes][attribute] as any;\n\n\t\tconst prevRef = refMap[key];\n\t\tif (prevRef) prevRef.dispose(); // TODO(cleanup): Possible duplicate event.\n\n\t\tif (!value) return this;\n\n\t\tmetadata = Object.assign(metadata || {}, { key: key });\n\t\tconst ref = this.graph.createEdge(attribute as string, this, value, { ...metadata, key });\n\t\tref.addEventListener('dispose', () => {\n\t\t\tdelete refMap[key];\n\t\t\tthis.dispatchEvent({ type: 'change', attribute, key });\n\t\t});\n\t\trefMap[key] = ref;\n\n\t\treturn this.dispatchEvent({ type: 'change', attribute, key });\n\t}\n\n\t/**********************************************************************************************\n\t * Events.\n\t */\n\n\tdispatchEvent(event: BaseEvent): this {\n\t\tsuper.dispatchEvent({ ...event, target: this });\n\t\tthis.graph.dispatchEvent({ ...event, target: this, type: `node:${event.type}` });\n\t\treturn this;\n\t}\n}\n","import { GraphNodeEvent } from '.';\nimport { EventDispatcher, GraphEdgeEvent, GraphEvent } from './event-dispatcher';\nimport { GraphEdge } from './graph-edge';\nimport { GraphNode } from './graph-node';\n\n/**\n * A graph manages a network of {@link GraphNode} nodes, connected\n * by {@link @Link} edges.\n *\n * @category Graph\n */\nexport class Graph<T extends GraphNode> extends EventDispatcher<GraphEvent | GraphNodeEvent | GraphEdgeEvent> {\n\tprivate _emptySet: Set<GraphEdge<T, T>> = new Set();\n\n\tprivate _edges: Set<GraphEdge<T, T>> = new Set();\n\tprivate _parentEdges: Map<T, Set<GraphEdge<T, T>>> = new Map();\n\tprivate _childEdges: Map<T, Set<GraphEdge<T, T>>> = new Map();\n\n\t/** Returns a list of all parent->child edges on this graph. */\n\tpublic listEdges(): GraphEdge<T, T>[] {\n\t\treturn Array.from(this._edges);\n\t}\n\n\t/** Returns a list of all edges on the graph having the given node as their child. */\n\tpublic listParentEdges(node: T): GraphEdge<T, T>[] {\n\t\treturn Array.from(this._childEdges.get(node) || this._emptySet);\n\t}\n\n\t/** Returns a list of parent nodes for the given child node. */\n\tpublic listParents(node: T): T[] {\n\t\treturn this.listParentEdges(node).map((edge) => edge.getParent());\n\t}\n\n\t/** Returns a list of all edges on the graph having the given node as their parent. */\n\tpublic listChildEdges(node: T): GraphEdge<T, T>[] {\n\t\treturn Array.from(this._parentEdges.get(node) || this._emptySet);\n\t}\n\n\t/** Returns a list of child nodes for the given parent node. */\n\tpublic listChildren(node: T): T[] {\n\t\treturn this.listChildEdges(node).map((edge) => edge.getChild());\n\t}\n\n\tpublic disconnectParents(node: T, filter?: (n: T) => boolean): this {\n\t\tlet edges = this.listParentEdges(node);\n\t\tif (filter) {\n\t\t\tedges = edges.filter((edge) => filter(edge.getParent()));\n\t\t}\n\t\tedges.forEach((edge) => edge.dispose());\n\t\treturn this;\n\t}\n\n\t/**\n\t * Creates a {@link GraphEdge} connecting two {@link GraphNode} instances. Edge is returned\n\t * for the caller to store.\n\t * @param a Owner\n\t * @param b Resource\n\t */\n\tpublic createEdge<A extends T, B extends T>(\n\t\tname: string,\n\t\ta: A,\n\t\tb: B,\n\t\tattributes?: Record<string, unknown>\n\t): GraphEdge<A, B> {\n\t\treturn this._registerEdge(new GraphEdge(name, a, b, attributes)) as GraphEdge<A, B>;\n\t}\n\n\t/**********************************************************************************************\n\t * Internal.\n\t */\n\n\tprivate _registerEdge(edge: GraphEdge<T, T>): GraphEdge<T, T> {\n\t\tthis._edges.add(edge);\n\n\t\tconst parent = edge.getParent();\n\t\tif (!this._parentEdges.has(parent)) this._parentEdges.set(parent, new Set());\n\t\tthis._parentEdges.get(parent)!.add(edge);\n\n\t\tconst child = edge.getChild();\n\t\tif (!this._childEdges.has(child)) this._childEdges.set(child, new Set());\n\t\tthis._childEdges.get(child)!.add(edge);\n\n\t\tedge.addEventListener('dispose', () => this._removeEdge(edge));\n\t\treturn edge;\n\t}\n\n\t/**\n\t * Removes the {@link GraphEdge} from the {@link Graph}. This method should only\n\t * be invoked by the onDispose() listener created in {@link _registerEdge()}. The\n\t * public method of removing an edge is {@link GraphEdge.dispose}.\n\t */\n\tprivate _removeEdge(edge: GraphEdge<T, T>): this {\n\t\tthis._edges.delete(edge);\n\t\tthis._parentEdges.get(edge.getParent())!.delete(edge);\n\t\tthis._childEdges.get(edge.getChild())!.delete(edge);\n\t\treturn this;\n\t}\n}\n"],"names":["EventDispatcher","_listeners","addEventListener","type","listener","listeners","this","undefined","indexOf","push","removeEventListener","listenerArray","index","splice","dispatchEvent","event","array","slice","i","l","length","call","dispose","key","GraphEdge","constructor","_name","_parent","_child","_attributes","super","_disposed","isOnGraph","Error","getName","getParent","getChild","setChild","child","getAttributes","target","isDisposed","isRef","value","isRefList","Array","isArray","isRefMap","Object","values","$attributes","Symbol","$immutableKeys","GraphNode","graph","Set","_createAttributes","getDefaults","defaultAttributes","attributes","ref","createEdge","add","other","listChildEdges","forEach","edge","disconnectParents","detach","swap","old","replacement","attribute","setRef","find","refAttributes","removeRef","addRef","refMap","setRefMap","get","set","getRef","has","prevRef","listRefs","map","refs","retained","filter","retainedRef","listRefMapKeys","keys","listRefMapValues","getRefMap","metadata","assign","_emptySet","_edges","_parentEdges","Map","_childEdges","listEdges","from","listParentEdges","node","listParents","listChildren","edges","name","a","b","_registerEdge","parent","_removeEdge","delete"],"mappings":"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"}