import {
  require_fs
} from "./chunk-5KWGEWPM.js";
import {
  __commonJS
} from "./chunk-4EOJPDL2.js";

// browser-external:path
var require_path = __commonJS({
  "browser-external:path"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/property-graph/dist/property-graph.modern.js
var t = class {
  constructor() {
    this._listeners = {};
  }
  addEventListener(t2, e2) {
    const s2 = this._listeners;
    return void 0 === s2[t2] && (s2[t2] = []), -1 === s2[t2].indexOf(e2) && s2[t2].push(e2), this;
  }
  removeEventListener(t2, e2) {
    if (void 0 === this._listeners)
      return this;
    const s2 = this._listeners[t2];
    if (void 0 !== s2) {
      const t3 = s2.indexOf(e2);
      -1 !== t3 && s2.splice(t3, 1);
    }
    return this;
  }
  dispatchEvent(t2) {
    if (void 0 === this._listeners)
      return this;
    const e2 = this._listeners[t2.type];
    if (void 0 !== e2) {
      const s2 = e2.slice(0);
      for (let e3 = 0, i2 = s2.length; e3 < i2; e3++)
        s2[e3].call(this, t2);
    }
    return this;
  }
  dispose() {
    for (const t2 in this._listeners)
      delete this._listeners[t2];
  }
};
var e = class extends t {
  constructor(t2, e2, s2, i2 = {}) {
    if (super(), this._name = void 0, this._parent = void 0, this._child = void 0, this._attributes = void 0, this._disposed = false, this._name = t2, this._parent = e2, this._child = s2, this._attributes = i2, !e2.isOnGraph(s2))
      throw new Error("Cannot connect disconnected graphs.");
  }
  getName() {
    return this._name;
  }
  getParent() {
    return this._parent;
  }
  getChild() {
    return this._child;
  }
  setChild(t2) {
    return this._child = t2, this;
  }
  getAttributes() {
    return this._attributes;
  }
  dispose() {
    this._disposed || (this._disposed = true, this.dispatchEvent({ type: "dispose", target: this }), super.dispose());
  }
  isDisposed() {
    return this._disposed;
  }
};
var s = class extends t {
  constructor(...t2) {
    super(...t2), this._emptySet = /* @__PURE__ */ new Set(), this._edges = /* @__PURE__ */ new Set(), this._parentEdges = /* @__PURE__ */ new Map(), this._childEdges = /* @__PURE__ */ new Map();
  }
  listEdges() {
    return Array.from(this._edges);
  }
  listParentEdges(t2) {
    return Array.from(this._childEdges.get(t2) || this._emptySet);
  }
  listParents(t2) {
    return this.listParentEdges(t2).map((t3) => t3.getParent());
  }
  listChildEdges(t2) {
    return Array.from(this._parentEdges.get(t2) || this._emptySet);
  }
  listChildren(t2) {
    return this.listChildEdges(t2).map((t3) => t3.getChild());
  }
  disconnectParents(t2, e2) {
    let s2 = this.listParentEdges(t2);
    return e2 && (s2 = s2.filter((t3) => e2(t3.getParent()))), s2.forEach((t3) => t3.dispose()), this;
  }
  createEdge(t2, s2, i2, r2) {
    return this._registerEdge(new e(t2, s2, i2, r2));
  }
  _registerEdge(t2) {
    this._edges.add(t2);
    const e2 = t2.getParent();
    this._parentEdges.has(e2) || this._parentEdges.set(e2, /* @__PURE__ */ new Set()), this._parentEdges.get(e2).add(t2);
    const s2 = t2.getChild();
    return this._childEdges.has(s2) || this._childEdges.set(s2, /* @__PURE__ */ new Set()), this._childEdges.get(s2).add(t2), t2.addEventListener("dispose", () => this._removeEdge(t2)), t2;
  }
  _removeEdge(t2) {
    return this._edges.delete(t2), this._parentEdges.get(t2.getParent()).delete(t2), this._childEdges.get(t2.getChild()).delete(t2), this;
  }
};
function i() {
  return i = Object.assign || function(t2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var s2 = arguments[e2];
      for (var i2 in s2)
        Object.prototype.hasOwnProperty.call(s2, i2) && (t2[i2] = s2[i2]);
    }
    return t2;
  }, i.apply(this, arguments);
}
function r(t2) {
  return t2 instanceof e;
}
function n(t2) {
  return Array.isArray(t2) && t2[0] instanceof e;
}
function h(t2) {
  return !!(t2 && "object" == typeof t2 && Object.values(t2)[0] instanceof e);
}
var d = Symbol("attributes");
var a = Symbol("immutableKeys");
var o = class extends t {
  constructor(t2) {
    super(), this._disposed = false, this.graph = void 0, this[d] = void 0, this[a] = void 0, this.graph = t2, this[a] = /* @__PURE__ */ new Set(), this[d] = this._createAttributes();
  }
  getDefaults() {
    return {};
  }
  _createAttributes() {
    const t2 = this.getDefaults(), e2 = {};
    for (const s2 in t2) {
      const i2 = t2[s2];
      if (i2 instanceof o) {
        const t3 = this.graph.createEdge(s2, this, i2);
        t3.addEventListener("dispose", () => i2.dispose()), this[a].add(s2), e2[s2] = t3;
      } else
        e2[s2] = i2;
    }
    return e2;
  }
  isOnGraph(t2) {
    return this.graph === t2.graph;
  }
  isDisposed() {
    return this._disposed;
  }
  dispose() {
    this._disposed || (this.graph.listChildEdges(this).forEach((t2) => t2.dispose()), this.graph.disconnectParents(this), this._disposed = true, this.dispatchEvent({ type: "dispose" }));
  }
  detach() {
    return this.graph.disconnectParents(this), this;
  }
  swap(t2, e2) {
    for (const s2 in this[d]) {
      const i2 = this[d][s2];
      if (r(i2)) {
        const r2 = i2;
        r2.getChild() === t2 && this.setRef(s2, e2, r2.getAttributes());
      } else if (n(i2)) {
        const r2 = i2.find((e3) => e3.getChild() === t2);
        if (r2) {
          const i3 = r2.getAttributes();
          this.removeRef(s2, t2).addRef(s2, e2, i3);
        }
      } else if (h(i2)) {
        const r2 = i2;
        for (const i3 in r2) {
          const n2 = r2[i3];
          n2.getChild() === t2 && this.setRefMap(s2, i3, e2, n2.getAttributes());
        }
      }
    }
    return this;
  }
  get(t2) {
    return this[d][t2];
  }
  set(t2, e2) {
    return this[d][t2] = e2, this.dispatchEvent({ type: "change", attribute: t2 });
  }
  getRef(t2) {
    const e2 = this[d][t2];
    return e2 ? e2.getChild() : null;
  }
  setRef(t2, e2, s2) {
    if (this[a].has(t2))
      throw new Error(`Cannot overwrite immutable attribute, "${t2}".`);
    const i2 = this[d][t2];
    if (i2 && i2.dispose(), !e2)
      return this;
    const r2 = this.graph.createEdge(t2, this, e2, s2);
    return r2.addEventListener("dispose", () => {
      delete this[d][t2], this.dispatchEvent({ type: "change", attribute: t2 });
    }), this[d][t2] = r2, this.dispatchEvent({ type: "change", attribute: t2 });
  }
  listRefs(t2) {
    return this[d][t2].map((t3) => t3.getChild());
  }
  addRef(t2, e2, s2) {
    const i2 = this.graph.createEdge(t2, this, e2, s2), r2 = this[d][t2];
    return r2.push(i2), i2.addEventListener("dispose", () => {
      const e3 = r2.filter((t3) => t3 !== i2);
      r2.length = 0;
      for (const t3 of e3)
        r2.push(t3);
      this.dispatchEvent({ type: "change", attribute: t2 });
    }), this.dispatchEvent({ type: "change", attribute: t2 });
  }
  removeRef(t2, e2) {
    return this[d][t2].filter((t3) => t3.getChild() === e2).forEach((t3) => t3.dispose()), this;
  }
  listRefMapKeys(t2) {
    return Object.keys(this[d][t2]);
  }
  listRefMapValues(t2) {
    return Object.values(this[d][t2]).map((t3) => t3.getChild());
  }
  getRefMap(t2, e2) {
    const s2 = this[d][t2];
    return s2[e2] ? s2[e2].getChild() : null;
  }
  setRefMap(t2, e2, s2, r2) {
    const n2 = this[d][t2], h2 = n2[e2];
    if (h2 && h2.dispose(), !s2)
      return this;
    r2 = Object.assign(r2 || {}, { key: e2 });
    const a2 = this.graph.createEdge(t2, this, s2, i({}, r2, { key: e2 }));
    return a2.addEventListener("dispose", () => {
      delete n2[e2], this.dispatchEvent({ type: "change", attribute: t2, key: e2 });
    }), n2[e2] = a2, this.dispatchEvent({ type: "change", attribute: t2, key: e2 });
  }
  dispatchEvent(t2) {
    return super.dispatchEvent(i({}, t2, { target: this })), this.graph.dispatchEvent(i({}, t2, { target: this, type: `node:${t2.type}` })), this;
  }
};

// node_modules/gl-matrix/esm/common.js
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var degree = Math.PI / 180;
if (!Math.hypot)
  Math.hypot = function() {
    var y2 = 0, i2 = arguments.length;
    while (i2--) {
      y2 += arguments[i2] * arguments[i2];
    }
    return Math.sqrt(y2);
  };

// node_modules/gl-matrix/esm/vec3.js
function create() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function length(a2) {
  var x2 = a2[0];
  var y2 = a2[1];
  var z2 = a2[2];
  return Math.hypot(x2, y2, z2);
}
function transformMat4(out, a2, m2) {
  var x2 = a2[0], y2 = a2[1], z2 = a2[2];
  var w2 = m2[3] * x2 + m2[7] * y2 + m2[11] * z2 + m2[15];
  w2 = w2 || 1;
  out[0] = (m2[0] * x2 + m2[4] * y2 + m2[8] * z2 + m2[12]) / w2;
  out[1] = (m2[1] * x2 + m2[5] * y2 + m2[9] * z2 + m2[13]) / w2;
  out[2] = (m2[2] * x2 + m2[6] * y2 + m2[10] * z2 + m2[14]) / w2;
  return out;
}
var forEach = function() {
  var vec = create();
  return function(a2, stride, offset, count, fn, arg) {
    var i2, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a2.length);
    } else {
      l = a2.length;
    }
    for (i2 = offset; i2 < l; i2 += stride) {
      vec[0] = a2[i2];
      vec[1] = a2[i2 + 1];
      vec[2] = a2[i2 + 2];
      fn(vec, vec, arg);
      a2[i2] = vec[0];
      a2[i2 + 1] = vec[1];
      a2[i2 + 2] = vec[2];
    }
    return a2;
  };
}();

// node_modules/gl-matrix/esm/mat4.js
function determinant(a2) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
  var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
  var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
  var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
function multiply(out, a2, b2) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
  var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
  var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
  var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
  var b0 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3];
  out[0] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
  b0 = b2[4];
  b1 = b2[5];
  b22 = b2[6];
  b3 = b2[7];
  out[4] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
  b0 = b2[8];
  b1 = b2[9];
  b22 = b2[10];
  b3 = b2[11];
  out[8] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
  b0 = b2[12];
  b1 = b2[13];
  b22 = b2[14];
  b3 = b2[15];
  out[12] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
  return out;
}
function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
function getRotation(out, mat) {
  var scaling = new ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S2 = 0;
  if (trace > 0) {
    S2 = Math.sqrt(trace + 1) * 2;
    out[3] = 0.25 * S2;
    out[0] = (sm23 - sm32) / S2;
    out[1] = (sm31 - sm13) / S2;
    out[2] = (sm12 - sm21) / S2;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S2 = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S2;
    out[0] = 0.25 * S2;
    out[1] = (sm12 + sm21) / S2;
    out[2] = (sm31 + sm13) / S2;
  } else if (sm22 > sm33) {
    S2 = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S2;
    out[0] = (sm12 + sm21) / S2;
    out[1] = 0.25 * S2;
    out[2] = (sm23 + sm32) / S2;
  } else {
    S2 = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S2;
    out[0] = (sm31 + sm13) / S2;
    out[1] = (sm23 + sm32) / S2;
    out[2] = 0.25 * S2;
  }
  return out;
}

// node_modules/@gltf-transform/core/dist/core.modern.js
var d2 = "v2.5.1";
var g = "@glb.bin";
var p;
var m;
var w;
var y;
var v;
var T;
function x(t2) {
  const e2 = { min: [Infinity, Infinity, Infinity], max: [-Infinity, -Infinity, -Infinity] }, r2 = t2.propertyType === p.NODE ? [t2] : t2.listChildren();
  for (const t3 of r2)
    t3.traverse((t4) => {
      const r3 = t4.getMesh();
      if (!r3)
        return;
      const s2 = b(r3, t4.getWorldMatrix());
      A(s2.min, e2), A(s2.max, e2);
    });
  return e2;
}
function b(t2, e2) {
  const r2 = { min: [Infinity, Infinity, Infinity], max: [-Infinity, -Infinity, -Infinity] };
  for (const s2 of t2.listPrimitives()) {
    const t3 = s2.getAttribute("POSITION");
    if (!t3)
      continue;
    let n2 = [0, 0, 0], i2 = [0, 0, 0];
    for (let s3 = 0; s3 < t3.getCount(); s3++)
      n2 = t3.getElement(s3, n2), i2 = transformMat4(i2, n2, e2), A(i2, r2);
  }
  return r2;
}
function A(t2, e2) {
  for (let r2 = 0; r2 < 3; r2++)
    e2.min[r2] = Math.min(t2[r2], e2.min[r2]), e2.max[r2] = Math.max(t2[r2], e2.max[r2]);
}
!function(t2) {
  t2.ACCESSOR = "Accessor", t2.ANIMATION = "Animation", t2.ANIMATION_CHANNEL = "AnimationChannel", t2.ANIMATION_SAMPLER = "AnimationSampler", t2.BUFFER = "Buffer", t2.CAMERA = "Camera", t2.MATERIAL = "Material", t2.MESH = "Mesh", t2.PRIMITIVE = "Primitive", t2.PRIMITIVE_TARGET = "PrimitiveTarget", t2.NODE = "Node", t2.ROOT = "Root", t2.SCENE = "Scene", t2.SKIN = "Skin", t2.TEXTURE = "Texture", t2.TEXTURE_INFO = "TextureInfo";
}(p || (p = {})), function(t2) {
  t2.INTERLEAVED = "interleaved", t2.SEPARATE = "separate";
}(m || (m = {})), function(t2) {
  t2.ARRAY_BUFFER = "ARRAY_BUFFER", t2.ELEMENT_ARRAY_BUFFER = "ELEMENT_ARRAY_BUFFER", t2.INVERSE_BIND_MATRICES = "INVERSE_BIND_MATRICES", t2.OTHER = "OTHER";
}(w || (w = {})), function(t2) {
  t2[t2.R = 4096] = "R", t2[t2.G = 256] = "G", t2[t2.B = 16] = "B", t2[t2.A = 1] = "A";
}(y || (y = {})), function(t2) {
  t2.GLTF = "GLTF", t2.GLB = "GLB";
}(v || (v = {}));
var E = class {
  static createBufferFromDataURI(t2) {
    if ("undefined" == typeof Buffer) {
      const e2 = atob(t2.split(",")[1]), r2 = new Uint8Array(e2.length);
      for (let t3 = 0; t3 < e2.length; t3++)
        r2[t3] = e2.charCodeAt(t3);
      return r2;
    }
    {
      const e2 = t2.split(",")[1], r2 = t2.indexOf("base64") >= 0;
      return Buffer.from(e2, r2 ? "base64" : "utf8");
    }
  }
  static encodeText(t2) {
    return "undefined" != typeof TextEncoder ? new TextEncoder().encode(t2) : Buffer.from(t2);
  }
  static decodeText(t2) {
    return "undefined" != typeof TextDecoder ? new TextDecoder().decode(t2) : Buffer.from(t2).toString("utf8");
  }
  static concat(t2) {
    let e2 = 0;
    for (const r3 of t2)
      e2 += r3.byteLength;
    const r2 = new Uint8Array(e2);
    let s2 = 0;
    for (const e3 of t2)
      r2.set(e3, s2), s2 += e3.byteLength;
    return r2;
  }
  static pad(t2, e2 = 0) {
    const r2 = this.padNumber(t2.byteLength);
    if (r2 === t2.byteLength)
      return t2;
    const s2 = new Uint8Array(r2);
    if (s2.set(t2), 0 !== e2)
      for (let n2 = t2.byteLength; n2 < r2; n2++)
        s2[n2] = e2;
    return s2;
  }
  static padNumber(t2) {
    return 4 * Math.ceil(t2 / 4);
  }
  static equals(t2, e2) {
    if (t2 === e2)
      return true;
    if (t2.byteLength !== e2.byteLength)
      return false;
    let r2 = t2.byteLength;
    for (; r2--; )
      if (t2[r2] !== e2[r2])
        return false;
    return true;
  }
  static toView(t2, e2 = 0, r2 = Infinity) {
    return new Uint8Array(t2.buffer, t2.byteOffset + e2, Math.min(t2.byteLength, r2));
  }
  static assertView(t2) {
    if (t2 && !ArrayBuffer.isView(t2))
      throw new Error(`Method requires Uint8Array parameter; received "${typeof t2}".`);
    return t2;
  }
};
var S = class {
  static hexToFactor(t2, e2) {
    t2 = Math.floor(t2);
    const r2 = e2;
    return r2[0] = (t2 >> 16 & 255) / 255, r2[1] = (t2 >> 8 & 255) / 255, r2[2] = (255 & t2) / 255, this.convertSRGBToLinear(e2, e2);
  }
  static factorToHex(t2) {
    const e2 = [...t2], [r2, s2, n2] = this.convertLinearToSRGB(t2, e2);
    return 255 * r2 << 16 ^ 255 * s2 << 8 ^ 255 * n2 << 0;
  }
  static convertSRGBToLinear(t2, e2) {
    const r2 = t2, s2 = e2;
    for (let t3 = 0; t3 < 3; t3++)
      s2[t3] = r2[t3] < 0.04045 ? 0.0773993808 * r2[t3] : Math.pow(0.9478672986 * r2[t3] + 0.0521327014, 2.4);
    return e2;
  }
  static convertLinearToSRGB(t2, e2) {
    const r2 = t2, s2 = e2;
    for (let t3 = 0; t3 < 3; t3++)
      s2[t3] = r2[t3] < 31308e-7 ? 12.92 * r2[t3] : 1.055 * Math.pow(r2[t3], 0.41666) - 0.055;
    return e2;
  }
};
var M = class {
  match(t2) {
    return t2.length >= 8 && 137 === t2[0] && 80 === t2[1] && 78 === t2[2] && 71 === t2[3] && 13 === t2[4] && 10 === t2[5] && 26 === t2[6] && 10 === t2[7];
  }
  getSize(t2) {
    const e2 = new DataView(t2.buffer, t2.byteOffset);
    return E.decodeText(t2.slice(12, 16)) === M.PNG_FRIED_CHUNK_NAME ? [e2.getUint32(32, false), e2.getUint32(36, false)] : [e2.getUint32(16, false), e2.getUint32(20, false)];
  }
  getChannels(t2) {
    return 4;
  }
};
M.PNG_FRIED_CHUNK_NAME = "CgBI";
var I = class {
  static registerFormat(t2, e2) {
    this.impls[t2] = e2;
  }
  static getMimeType(t2) {
    for (const e2 in this.impls)
      if (this.impls[e2].match(t2))
        return e2;
    return null;
  }
  static getSize(t2, e2) {
    return this.impls[e2] ? this.impls[e2].getSize(t2) : null;
  }
  static getChannels(t2, e2) {
    return this.impls[e2] ? this.impls[e2].getChannels(t2) : null;
  }
  static getMemSize(t2, e2) {
    if (!this.impls[e2])
      return null;
    if (this.impls[e2].getGPUByteLength)
      return this.impls[e2].getGPUByteLength(t2);
    let r2 = 0;
    const s2 = this.getSize(t2, e2);
    if (!s2)
      return null;
    for (; s2[0] > 1 || s2[1] > 1; )
      r2 += s2[0] * s2[1] * 4, s2[0] = Math.max(Math.floor(s2[0] / 2), 1), s2[1] = Math.max(Math.floor(s2[1] / 2), 1);
    return r2 += 4, r2;
  }
  static mimeTypeToExtension(t2) {
    return "image/jpeg" === t2 ? "jpg" : t2.split("/").pop();
  }
  static extensionToMimeType(t2) {
    return "jpg" === t2 ? "image/jpeg" : `image/${t2}`;
  }
};
function R(t2, e2) {
  if (e2 > t2.byteLength)
    throw new TypeError("Corrupt JPG, exceeded buffer limits");
  if (255 !== t2.getUint8(e2))
    throw new TypeError("Invalid JPG, marker table corrupted");
  return t2;
}
I.impls = { "image/jpeg": new class {
  match(t2) {
    return t2.length >= 3 && 255 === t2[0] && 216 === t2[1] && 255 === t2[2];
  }
  getSize(t2) {
    let e2, r2, s2 = new DataView(t2.buffer, t2.byteOffset + 4);
    for (; s2.byteLength; ) {
      if (e2 = s2.getUint16(0, false), R(s2, e2), r2 = s2.getUint8(e2 + 1), 192 === r2 || 193 === r2 || 194 === r2)
        return [s2.getUint16(e2 + 7, false), s2.getUint16(e2 + 5, false)];
      s2 = new DataView(t2.buffer, s2.byteOffset + e2 + 2);
    }
    throw new TypeError("Invalid JPG, no size found");
  }
  getChannels(t2) {
    return 3;
  }
}(), "image/png": new M() };
var N = class {
  static basename(t2) {
    const e2 = t2.split(/[\\/]/).pop();
    return e2.substring(0, e2.lastIndexOf("."));
  }
  static extension(t2) {
    if (t2.startsWith("data:image/")) {
      const e2 = t2.match(/data:(image\/\w+)/)[1];
      return I.mimeTypeToExtension(e2);
    }
    return t2.startsWith("data:model/gltf+json") ? "gltf" : t2.startsWith("data:model/gltf-binary") ? "glb" : t2.startsWith("data:application/") ? "bin" : t2.split(/[\\/]/).pop().split(/[.]/).pop();
  }
};
function O(t2) {
  return "[object Object]" === Object.prototype.toString.call(t2);
}
function C(t2) {
  if (false === O(t2))
    return false;
  const e2 = t2.constructor;
  if (void 0 === e2)
    return true;
  const r2 = e2.prototype;
  return false !== O(r2) && false !== Object.prototype.hasOwnProperty.call(r2, "isPrototypeOf");
}
!function(t2) {
  t2[t2.SILENT = 4] = "SILENT", t2[t2.ERROR = 3] = "ERROR", t2[t2.WARN = 2] = "WARN", t2[t2.INFO = 1] = "INFO", t2[t2.DEBUG = 0] = "DEBUG";
}(T || (T = {}));
var F = class {
  constructor(t2) {
    this.verbosity = void 0, this.verbosity = t2;
  }
  debug(t2) {
    this.verbosity <= F.Verbosity.DEBUG && console.debug(t2);
  }
  info(t2) {
    this.verbosity <= F.Verbosity.INFO && console.info(t2);
  }
  warn(t2) {
    this.verbosity <= F.Verbosity.WARN && console.warn(t2);
  }
  error(t2) {
    this.verbosity <= F.Verbosity.ERROR && console.error(t2);
  }
};
F.Verbosity = T, F.DEFAULT_INSTANCE = new F(F.Verbosity.INFO);
var B = class {
  static identity(t2) {
    return t2;
  }
  static eq(t2, e2, r2 = 1e-5) {
    if (t2.length !== e2.length)
      return false;
    for (let s2 = 0; s2 < t2.length; s2++)
      if (Math.abs(t2[s2] - e2[s2]) > r2)
        return false;
    return true;
  }
  static denormalize(t2, e2) {
    switch (e2) {
      case 5126:
        return t2;
      case 5123:
        return t2 / 65535;
      case 5121:
        return t2 / 255;
      case 5122:
        return Math.max(t2 / 32767, -1);
      case 5120:
        return Math.max(t2 / 127, -1);
      default:
        throw new Error("Invalid component type.");
    }
  }
  static normalize(t2, e2) {
    switch (e2) {
      case 5126:
        return t2;
      case 5123:
        return Math.round(65535 * t2);
      case 5121:
        return Math.round(255 * t2);
      case 5122:
        return Math.round(32767 * t2);
      case 5120:
        return Math.round(127 * t2);
      default:
        throw new Error("Invalid component type.");
    }
  }
  static decompose(t2, e2, r2, s2) {
    let n2 = length([t2[0], t2[1], t2[2]]);
    const i2 = length([t2[4], t2[5], t2[6]]), o2 = length([t2[8], t2[9], t2[10]]);
    determinant(t2) < 0 && (n2 = -n2), e2[0] = t2[12], e2[1] = t2[13], e2[2] = t2[14];
    const a2 = t2.slice(), u = 1 / n2, f = 1 / i2, d3 = 1 / o2;
    a2[0] *= u, a2[1] *= u, a2[2] *= u, a2[4] *= f, a2[5] *= f, a2[6] *= f, a2[8] *= d3, a2[9] *= d3, a2[10] *= d3, getRotation(r2, a2), s2[0] = n2, s2[1] = i2, s2[2] = o2;
  }
  static compose(t2, e2, r2, s2) {
    const n2 = s2, i2 = e2[0], o2 = e2[1], a2 = e2[2], u = e2[3], c = i2 + i2, h2 = o2 + o2, l = a2 + a2, f = i2 * c, d3 = i2 * h2, g2 = i2 * l, p2 = o2 * h2, m2 = o2 * l, w2 = a2 * l, y2 = u * c, v2 = u * h2, T2 = u * l, x2 = r2[0], b2 = r2[1], A2 = r2[2];
    return n2[0] = (1 - (p2 + w2)) * x2, n2[1] = (d3 + T2) * x2, n2[2] = (g2 - v2) * x2, n2[3] = 0, n2[4] = (d3 - T2) * b2, n2[5] = (1 - (f + w2)) * b2, n2[6] = (m2 + y2) * b2, n2[7] = 0, n2[8] = (g2 + v2) * A2, n2[9] = (m2 - y2) * A2, n2[10] = (1 - (f + p2)) * A2, n2[11] = 0, n2[12] = t2[0], n2[13] = t2[1], n2[14] = t2[2], n2[15] = 1, n2;
  }
};
function P(t2, e2) {
  if (!!t2 != !!e2)
    return false;
  const r2 = t2.getChild(), s2 = e2.getChild();
  return r2 === s2 || r2.equals(s2);
}
function U(t2, e2) {
  if (!!t2 != !!e2)
    return false;
  if (t2.length !== e2.length)
    return false;
  for (let r2 = 0; r2 < t2.length; r2++) {
    const s2 = t2[r2], n2 = e2[r2];
    if (s2.getChild() !== n2.getChild() && !s2.getChild().equals(n2.getChild()))
      return false;
  }
  return true;
}
function j(t2, e2) {
  if (!!t2 != !!e2)
    return false;
  const r2 = Object.keys(t2), s2 = Object.keys(e2);
  if (r2.length !== s2.length)
    return false;
  for (const r3 in t2) {
    const s3 = t2[r3], n2 = e2[r3];
    if (!!s3 != !!n2)
      return false;
    const i2 = s3.getChild(), o2 = n2.getChild();
    if (i2 !== o2 && !i2.equals(o2))
      return false;
  }
  return true;
}
function L(t2, e2) {
  if (t2 === e2)
    return true;
  if (!!t2 != !!e2 || !t2 || !e2)
    return false;
  if (t2.length !== e2.length)
    return false;
  for (let r2 = 0; r2 < t2.length; r2++)
    if (t2[r2] !== e2[r2])
      return false;
  return true;
}
function _(t2, e2) {
  if (t2 === e2)
    return true;
  if (!!t2 != !!e2)
    return false;
  if (!C(t2) || !C(e2))
    return t2 === e2;
  const r2 = t2, s2 = e2;
  let n2, i2 = 0, o2 = 0;
  for (n2 in r2)
    i2++;
  for (n2 in s2)
    o2++;
  if (i2 !== o2)
    return false;
  for (n2 in r2) {
    const t3 = r2[n2], e3 = s2[n2];
    if (D(t3) && D(e3)) {
      if (!L(t3, e3))
        return false;
    } else if (C(t3) && C(e3)) {
      if (!_(t3, e3))
        return false;
    } else if (t3 !== e3)
      return false;
  }
  return true;
}
function D(t2) {
  return Array.isArray(t2) || ArrayBuffer.isView(t2);
}
var k = "23456789abdegjkmnpqrvwxyzABDEGJKMNPQRVWXYZ";
var z = /* @__PURE__ */ new Set();
var G = function() {
  let t2 = "";
  for (let e2 = 0; e2 < 6; e2++)
    t2 += k.charAt(Math.floor(Math.random() * k.length));
  return t2;
};
var J = function() {
  for (let t2 = 0; t2 < 999; t2++) {
    const t3 = G();
    if (!z.has(t3))
      return z.add(t3), t3;
  }
  return "";
};
var $ = class {
  static dirname(t2) {
    const e2 = t2.lastIndexOf("/");
    return -1 === e2 ? "./" : t2.substring(0, e2 + 1);
  }
  static basename(t2) {
    return N.basename(new URL(t2, "https://null.example").pathname);
  }
  static extension(t2) {
    return N.extension(new URL(t2, "https://null.example").pathname);
  }
  static resolve(t2, e2) {
    if (!this.isRelativePath(e2))
      return e2;
    const r2 = t2.split("/"), s2 = e2.split("/");
    r2.pop();
    for (let t3 = 0; t3 < s2.length; t3++)
      "." !== s2[t3] && (".." === s2[t3] ? r2.pop() : r2.push(s2[t3]));
    return r2.join("/");
  }
  static isAbsoluteURL(t2) {
    return this.PROTOCOL_REGEXP.test(t2);
  }
  static isRelativePath(t2) {
    return !/^(?:[a-zA-Z]+:)?\//.test(t2);
  }
};
$.DEFAULT_INIT = {}, $.PROTOCOL_REGEXP = /^[a-zA-Z]+:\/\//;
var V = (t2) => t2;
var q = /* @__PURE__ */ new Set();
var W = class extends o {
  constructor(t2, r2 = "") {
    super(t2), this[d].name = r2, this.init(), this.dispatchEvent({ type: "create" });
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), { name: "", extras: {} });
  }
  getName() {
    return this.get("name");
  }
  setName(t2) {
    return this.set("name", t2);
  }
  getExtras() {
    return this.get("extras");
  }
  setExtras(t2) {
    return this.set("extras", t2);
  }
  clone() {
    return new (0, this.constructor)(this.graph).copy(this, V);
  }
  copy(t2, o2 = V) {
    for (const t3 in this[d]) {
      const o3 = this[d][t3];
      if (o3 instanceof e)
        this[a].has(t3) || o3.dispose();
      else if (n(o3))
        for (const t4 of o3)
          t4.dispose();
      else if (h(o3))
        for (const t4 in o3)
          o3[t4].dispose();
    }
    for (const a2 in t2[d]) {
      const u = this[d][a2], c = t2[d][a2];
      if (c instanceof e)
        this[a].has(a2) ? u.getChild().copy(o2(c.getChild()), o2) : this.setRef(a2, o2(c.getChild()), c.getAttributes());
      else if (n(c))
        for (const t3 of c)
          this.addRef(a2, o2(t3.getChild()), t3.getAttributes());
      else if (h(c))
        for (const t3 in c) {
          const e2 = c[t3];
          this.setRefMap(a2, t3, o2(e2.getChild()), e2.getAttributes());
        }
      else
        this[d][a2] = C(c) ? JSON.parse(JSON.stringify(c)) : Array.isArray(c) || c instanceof ArrayBuffer || ArrayBuffer.isView(c) ? c.slice() : c;
    }
    return this;
  }
  equals(t2, r2 = q) {
    if (this === t2)
      return true;
    if (this.propertyType !== t2.propertyType)
      return false;
    for (const s2 in this[d]) {
      if (r2.has(s2))
        continue;
      const a2 = this[d][s2], u = t2[d][s2];
      if (r(a2) || r(u)) {
        if (!P(a2, u))
          return false;
      } else if (n(a2) || n(u)) {
        if (!U(a2, u))
          return false;
      } else if (h(a2) || h(u)) {
        if (!j(a2, u))
          return false;
      } else if (C(a2) || C(u)) {
        if (!_(a2, u))
          return false;
      } else if (D(a2) || D(u)) {
        if (!L(a2, u))
          return false;
      } else if (a2 !== u)
        return false;
    }
    return true;
  }
  detach() {
    return this.graph.disconnectParents(this, (t2) => "Root" !== t2.propertyType), this;
  }
  listParents() {
    return this.graph.listParents(this);
  }
};
var H = class extends W {
  getDefaults() {
    return Object.assign(super.getDefaults(), { extensions: {} });
  }
  getExtension(t2) {
    return this.getRefMap("extensions", t2);
  }
  setExtension(t2, e2) {
    return e2 && e2.t(this), this.setRefMap("extensions", t2, e2);
  }
  listExtensions() {
    return this.listRefMapValues("extensions");
  }
};
var Y = class extends H {
  constructor(...t2) {
    super(...t2), this.i = B.identity, this.o = B.identity;
  }
  init() {
    this.propertyType = p.ACCESSOR;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), { array: null, type: Y.Type.SCALAR, componentType: Y.ComponentType.FLOAT, normalized: false, buffer: null });
  }
  copy(t2, e2 = V) {
    return super.copy(t2, e2), this.i = t2.i, this.o = t2.o, this;
  }
  static getElementSize(t2) {
    switch (t2) {
      case Y.Type.SCALAR:
        return 1;
      case Y.Type.VEC2:
        return 2;
      case Y.Type.VEC3:
        return 3;
      case Y.Type.VEC4:
      case Y.Type.MAT2:
        return 4;
      case Y.Type.MAT3:
        return 9;
      case Y.Type.MAT4:
        return 16;
      default:
        throw new Error("Unexpected type: " + t2);
    }
  }
  static getComponentSize(t2) {
    switch (t2) {
      case Y.ComponentType.BYTE:
      case Y.ComponentType.UNSIGNED_BYTE:
        return 1;
      case Y.ComponentType.SHORT:
      case Y.ComponentType.UNSIGNED_SHORT:
        return 2;
      case Y.ComponentType.UNSIGNED_INT:
      case Y.ComponentType.FLOAT:
        return 4;
      default:
        throw new Error("Unexpected component type: " + t2);
    }
  }
  getMinNormalized(t2) {
    const e2 = this.getElementSize();
    this.getMin(t2);
    for (let r2 = 0; r2 < e2; r2++)
      t2[r2] = this.o(t2[r2]);
    return t2;
  }
  getMin(t2) {
    const e2 = this.get("array"), r2 = this.getCount(), s2 = this.getElementSize();
    for (let e3 = 0; e3 < s2; e3++)
      t2[e3] = Infinity;
    for (let n2 = 0; n2 < r2 * s2; n2 += s2)
      for (let r3 = 0; r3 < s2; r3++) {
        const s3 = e2[n2 + r3];
        Number.isFinite(s3) && (t2[r3] = Math.min(t2[r3], s3));
      }
    return t2;
  }
  getMaxNormalized(t2) {
    const e2 = this.getElementSize();
    this.getMax(t2);
    for (let r2 = 0; r2 < e2; r2++)
      t2[r2] = this.o(t2[r2]);
    return t2;
  }
  getMax(t2) {
    const e2 = this.get("array"), r2 = this.getCount(), s2 = this.getElementSize();
    for (let e3 = 0; e3 < s2; e3++)
      t2[e3] = -Infinity;
    for (let n2 = 0; n2 < r2 * s2; n2 += s2)
      for (let r3 = 0; r3 < s2; r3++) {
        const s3 = e2[n2 + r3];
        Number.isFinite(s3) && (t2[r3] = Math.max(t2[r3], s3));
      }
    return t2;
  }
  getCount() {
    const t2 = this.get("array");
    return t2 ? t2.length / this.getElementSize() : 0;
  }
  getType() {
    return this.get("type");
  }
  setType(t2) {
    return this.set("type", t2);
  }
  getElementSize() {
    return Y.getElementSize(this.get("type"));
  }
  getComponentSize() {
    return this.get("array").BYTES_PER_ELEMENT;
  }
  getComponentType() {
    return this.get("componentType");
  }
  getNormalized() {
    return this.get("normalized");
  }
  setNormalized(t2) {
    return this.set("normalized", t2), t2 ? (this.o = (t3) => B.denormalize(t3, this.get("componentType")), this.i = (t3) => B.normalize(t3, this.get("componentType"))) : (this.o = B.identity, this.i = B.identity), this;
  }
  getScalar(t2) {
    const e2 = this.getElementSize();
    return this.o(this.get("array")[t2 * e2]);
  }
  setScalar(t2, e2) {
    return this.get("array")[t2 * this.getElementSize()] = this.i(e2), this;
  }
  getElement(t2, e2) {
    const r2 = this.getElementSize(), s2 = this.get("array");
    for (let n2 = 0; n2 < r2; n2++)
      e2[n2] = this.o(s2[t2 * r2 + n2]);
    return e2;
  }
  setElement(t2, e2) {
    const r2 = this.getElementSize(), s2 = this.get("array");
    for (let n2 = 0; n2 < r2; n2++)
      s2[t2 * r2 + n2] = this.i(e2[n2]);
    return this;
  }
  getBuffer() {
    return this.getRef("buffer");
  }
  setBuffer(t2) {
    return this.setRef("buffer", t2);
  }
  getArray() {
    return this.get("array");
  }
  setArray(t2) {
    return this.set("componentType", t2 ? function(t3) {
      switch (t3.constructor) {
        case Float32Array:
          return Y.ComponentType.FLOAT;
        case Uint32Array:
          return Y.ComponentType.UNSIGNED_INT;
        case Uint16Array:
          return Y.ComponentType.UNSIGNED_SHORT;
        case Uint8Array:
          return Y.ComponentType.UNSIGNED_BYTE;
        case Int16Array:
          return Y.ComponentType.SHORT;
        case Int8Array:
          return Y.ComponentType.BYTE;
        default:
          throw new Error("Unknown accessor componentType.");
      }
    }(t2) : Y.ComponentType.FLOAT), this.set("array", t2), this;
  }
  getByteLength() {
    const t2 = this.get("array");
    return t2 ? t2.byteLength : 0;
  }
};
Y.Type = { SCALAR: "SCALAR", VEC2: "VEC2", VEC3: "VEC3", VEC4: "VEC4", MAT2: "MAT2", MAT3: "MAT3", MAT4: "MAT4" }, Y.ComponentType = { BYTE: 5120, UNSIGNED_BYTE: 5121, SHORT: 5122, UNSIGNED_SHORT: 5123, UNSIGNED_INT: 5125, FLOAT: 5126 };
var Z = class extends H {
  init() {
    this.propertyType = p.ANIMATION;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), { channels: [], samplers: [] });
  }
  addChannel(t2) {
    return this.addRef("channels", t2);
  }
  removeChannel(t2) {
    return this.removeRef("channels", t2);
  }
  listChannels() {
    return this.listRefs("channels");
  }
  addSampler(t2) {
    return this.addRef("samplers", t2);
  }
  removeSampler(t2) {
    return this.removeRef("samplers", t2);
  }
  listSamplers() {
    return this.listRefs("samplers");
  }
};
var K = class extends H {
  init() {
    this.propertyType = p.ANIMATION_CHANNEL;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), { targetPath: null, targetNode: null, sampler: null });
  }
  getTargetPath() {
    return this.get("targetPath");
  }
  setTargetPath(t2) {
    return this.set("targetPath", t2);
  }
  getTargetNode() {
    return this.getRef("targetNode");
  }
  setTargetNode(t2) {
    return this.setRef("targetNode", t2);
  }
  getSampler() {
    return this.getRef("sampler");
  }
  setSampler(t2) {
    return this.setRef("sampler", t2);
  }
};
K.TargetPath = { TRANSLATION: "translation", ROTATION: "rotation", SCALE: "scale", WEIGHTS: "weights" };
var Q = class extends H {
  init() {
    this.propertyType = p.ANIMATION_SAMPLER;
  }
  getDefaultAttributes() {
    return Object.assign(super.getDefaults(), { interpolation: Q.Interpolation.LINEAR, input: null, output: null });
  }
  getInterpolation() {
    return this.get("interpolation");
  }
  setInterpolation(t2) {
    return this.set("interpolation", t2);
  }
  getInput() {
    return this.getRef("input");
  }
  setInput(t2) {
    return this.setRef("input", t2, { usage: w.OTHER });
  }
  getOutput() {
    return this.getRef("output");
  }
  setOutput(t2) {
    return this.setRef("output", t2, { usage: w.OTHER });
  }
};
Q.Interpolation = { LINEAR: "LINEAR", STEP: "STEP", CUBICSPLINE: "CUBICSPLINE" };
var X = class extends H {
  init() {
    this.propertyType = p.BUFFER;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), { uri: "" });
  }
  getURI() {
    return this.get("uri");
  }
  setURI(t2) {
    return this.set("uri", t2);
  }
};
var tt = class extends H {
  init() {
    this.propertyType = p.CAMERA;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), { type: tt.Type.PERSPECTIVE, znear: 0.1, zfar: 100, aspectRatio: null, yfov: 2 * Math.PI * 50 / 360, xmag: 1, ymag: 1 });
  }
  getType() {
    return this.get("type");
  }
  setType(t2) {
    return this.set("type", t2);
  }
  getZNear() {
    return this.get("znear");
  }
  setZNear(t2) {
    return this.set("znear", t2);
  }
  getZFar() {
    return this.get("zfar");
  }
  setZFar(t2) {
    return this.set("zfar", t2);
  }
  getAspectRatio() {
    return this.get("aspectRatio");
  }
  setAspectRatio(t2) {
    return this.set("aspectRatio", t2);
  }
  getYFov() {
    return this.get("yfov");
  }
  setYFov(t2) {
    return this.set("yfov", t2);
  }
  getXMag() {
    return this.get("xmag");
  }
  setXMag(t2) {
    return this.set("xmag", t2);
  }
  getYMag() {
    return this.get("ymag");
  }
  setYMag(t2) {
    return this.set("ymag", t2);
  }
};
tt.Type = { PERSPECTIVE: "perspective", ORTHOGRAPHIC: "orthographic" };
var et = class extends W {
  t(t2) {
    if (!this.parentTypes.includes(t2.propertyType))
      throw new Error(`Parent "${t2.propertyType}" invalid for child "${this.propertyType}".`);
  }
};
et.EXTENSION_NAME = void 0;
var rt = class extends H {
  init() {
    this.propertyType = p.TEXTURE_INFO;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), { texCoord: 0, magFilter: null, minFilter: null, wrapS: rt.WrapMode.REPEAT, wrapT: rt.WrapMode.REPEAT });
  }
  getTexCoord() {
    return this.get("texCoord");
  }
  setTexCoord(t2) {
    return this.set("texCoord", t2);
  }
  getMagFilter() {
    return this.get("magFilter");
  }
  setMagFilter(t2) {
    return this.set("magFilter", t2);
  }
  getMinFilter() {
    return this.get("minFilter");
  }
  setMinFilter(t2) {
    return this.set("minFilter", t2);
  }
  getWrapS() {
    return this.get("wrapS");
  }
  setWrapS(t2) {
    return this.set("wrapS", t2);
  }
  getWrapT() {
    return this.get("wrapT");
  }
  setWrapT(t2) {
    return this.set("wrapT", t2);
  }
};
rt.WrapMode = { CLAMP_TO_EDGE: 33071, MIRRORED_REPEAT: 33648, REPEAT: 10497 }, rt.MagFilter = { NEAREST: 9728, LINEAR: 9729 }, rt.MinFilter = { NEAREST: 9728, LINEAR: 9729, NEAREST_MIPMAP_NEAREST: 9984, LINEAR_MIPMAP_NEAREST: 9985, NEAREST_MIPMAP_LINEAR: 9986, LINEAR_MIPMAP_LINEAR: 9987 };
var { R: st, G: nt, B: it, A: ot } = y;
var at = class extends H {
  init() {
    this.propertyType = p.MATERIAL;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), { alphaMode: at.AlphaMode.OPAQUE, alphaCutoff: 0.5, doubleSided: false, baseColorFactor: [1, 1, 1, 1], baseColorTexture: null, baseColorTextureInfo: new rt(this.graph, "baseColorTextureInfo"), emissiveFactor: [0, 0, 0], emissiveTexture: null, emissiveTextureInfo: new rt(this.graph, "emissiveTextureInfo"), normalScale: 1, normalTexture: null, normalTextureInfo: new rt(this.graph, "normalTextureInfo"), occlusionStrength: 1, occlusionTexture: null, occlusionTextureInfo: new rt(this.graph, "occlusionTextureInfo"), roughnessFactor: 1, metallicFactor: 1, metallicRoughnessTexture: null, metallicRoughnessTextureInfo: new rt(this.graph, "metallicRoughnessTextureInfo") });
  }
  getDoubleSided() {
    return this.get("doubleSided");
  }
  setDoubleSided(t2) {
    return this.set("doubleSided", t2);
  }
  getAlpha() {
    return this.get("baseColorFactor")[3];
  }
  setAlpha(t2) {
    const e2 = this.get("baseColorFactor").slice();
    return e2[3] = t2, this.set("baseColorFactor", e2);
  }
  getAlphaMode() {
    return this.get("alphaMode");
  }
  setAlphaMode(t2) {
    return this.set("alphaMode", t2);
  }
  getAlphaCutoff() {
    return this.get("alphaCutoff");
  }
  setAlphaCutoff(t2) {
    return this.set("alphaCutoff", t2);
  }
  getBaseColorFactor() {
    return this.get("baseColorFactor");
  }
  setBaseColorFactor(t2) {
    return this.set("baseColorFactor", t2);
  }
  getBaseColorHex() {
    return S.factorToHex(this.get("baseColorFactor"));
  }
  setBaseColorHex(t2) {
    const e2 = this.get("baseColorFactor").slice();
    return this.set("baseColorFactor", S.hexToFactor(t2, e2));
  }
  getBaseColorTexture() {
    return this.getRef("baseColorTexture");
  }
  getBaseColorTextureInfo() {
    return this.getRef("baseColorTexture") ? this.getRef("baseColorTextureInfo") : null;
  }
  setBaseColorTexture(t2) {
    return this.setRef("baseColorTexture", t2, { channels: st | nt | it | ot });
  }
  getEmissiveFactor() {
    return this.get("emissiveFactor");
  }
  setEmissiveFactor(t2) {
    return this.set("emissiveFactor", t2);
  }
  getEmissiveHex() {
    return S.factorToHex(this.get("emissiveFactor"));
  }
  setEmissiveHex(t2) {
    const e2 = this.get("emissiveFactor").slice();
    return this.set("emissiveFactor", S.hexToFactor(t2, e2));
  }
  getEmissiveTexture() {
    return this.getRef("emissiveTexture");
  }
  getEmissiveTextureInfo() {
    return this.getRef("emissiveTexture") ? this.getRef("emissiveTextureInfo") : null;
  }
  setEmissiveTexture(t2) {
    return this.setRef("emissiveTexture", t2, { channels: st | nt | it });
  }
  getNormalScale() {
    return this.get("normalScale");
  }
  setNormalScale(t2) {
    return this.set("normalScale", t2);
  }
  getNormalTexture() {
    return this.getRef("normalTexture");
  }
  getNormalTextureInfo() {
    return this.getRef("normalTexture") ? this.getRef("normalTextureInfo") : null;
  }
  setNormalTexture(t2) {
    return this.setRef("normalTexture", t2, { channels: st | nt | it });
  }
  getOcclusionStrength() {
    return this.get("occlusionStrength");
  }
  setOcclusionStrength(t2) {
    return this.set("occlusionStrength", t2);
  }
  getOcclusionTexture() {
    return this.getRef("occlusionTexture");
  }
  getOcclusionTextureInfo() {
    return this.getRef("occlusionTexture") ? this.getRef("occlusionTextureInfo") : null;
  }
  setOcclusionTexture(t2) {
    return this.setRef("occlusionTexture", t2, { channels: st });
  }
  getRoughnessFactor() {
    return this.get("roughnessFactor");
  }
  setRoughnessFactor(t2) {
    return this.set("roughnessFactor", t2);
  }
  getMetallicFactor() {
    return this.get("metallicFactor");
  }
  setMetallicFactor(t2) {
    return this.set("metallicFactor", t2);
  }
  getMetallicRoughnessTexture() {
    return this.getRef("metallicRoughnessTexture");
  }
  getMetallicRoughnessTextureInfo() {
    return this.getRef("metallicRoughnessTexture") ? this.getRef("metallicRoughnessTextureInfo") : null;
  }
  setMetallicRoughnessTexture(t2) {
    return this.setRef("metallicRoughnessTexture", t2, { channels: nt | it });
  }
};
at.AlphaMode = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
var ut = class extends H {
  init() {
    this.propertyType = p.MESH;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), { weights: [], primitives: [] });
  }
  addPrimitive(t2) {
    return this.addRef("primitives", t2);
  }
  removePrimitive(t2) {
    return this.removeRef("primitives", t2);
  }
  listPrimitives() {
    return this.listRefs("primitives");
  }
  getWeights() {
    return this.get("weights");
  }
  setWeights(t2) {
    return this.set("weights", t2);
  }
};
var ct = class extends H {
  constructor(...t2) {
    super(...t2), this.u = null;
  }
  init() {
    this.propertyType = p.NODE;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), { translation: [0, 0, 0], rotation: [0, 0, 0, 1], scale: [1, 1, 1], weights: [], camera: null, mesh: null, skin: null, children: [] });
  }
  copy(t2, e2 = V) {
    if (e2 === V)
      throw new Error("Node cannot be copied.");
    return super.copy(t2, e2);
  }
  getTranslation() {
    return this.get("translation");
  }
  getRotation() {
    return this.get("rotation");
  }
  getScale() {
    return this.get("scale");
  }
  setTranslation(t2) {
    return this.set("translation", t2);
  }
  setRotation(t2) {
    return this.set("rotation", t2);
  }
  setScale(t2) {
    return this.set("scale", t2);
  }
  getMatrix() {
    return B.compose(this.get("translation"), this.get("rotation"), this.get("scale"), []);
  }
  setMatrix(t2) {
    const e2 = this.get("translation").slice(), r2 = this.get("rotation").slice(), s2 = this.get("scale").slice();
    return B.decompose(t2, e2, r2, s2), this.set("translation", e2).set("rotation", r2).set("scale", s2);
  }
  getWorldTranslation() {
    const t2 = [0, 0, 0];
    return B.decompose(this.getWorldMatrix(), t2, [0, 0, 0, 1], [1, 1, 1]), t2;
  }
  getWorldRotation() {
    const t2 = [0, 0, 0, 1];
    return B.decompose(this.getWorldMatrix(), [0, 0, 0], t2, [1, 1, 1]), t2;
  }
  getWorldScale() {
    const t2 = [1, 1, 1];
    return B.decompose(this.getWorldMatrix(), [0, 0, 0], [0, 0, 0, 1], t2), t2;
  }
  getWorldMatrix() {
    const t2 = [];
    for (let e3 = this; e3 instanceof ct; e3 = e3.u)
      t2.push(e3);
    let e2;
    const r2 = t2.pop().getMatrix();
    for (; e2 = t2.pop(); )
      multiply(r2, r2, e2.getMatrix());
    return r2;
  }
  addChild(t2) {
    t2.u && t2.u.removeChild(t2), this.addRef("children", t2), t2.u = this;
    const r2 = this[d].children;
    return r2[r2.length - 1].addEventListener("dispose", () => t2.u = null), this;
  }
  removeChild(t2) {
    return this.removeRef("children", t2);
  }
  listChildren() {
    return this.listRefs("children");
  }
  getParent() {
    return this.u;
  }
  getMesh() {
    return this.getRef("mesh");
  }
  setMesh(t2) {
    return this.setRef("mesh", t2);
  }
  getCamera() {
    return this.getRef("camera");
  }
  setCamera(t2) {
    return this.setRef("camera", t2);
  }
  getSkin() {
    return this.getRef("skin");
  }
  setSkin(t2) {
    return this.setRef("skin", t2);
  }
  getWeights() {
    return this.get("weights");
  }
  setWeights(t2) {
    return this.set("weights", t2);
  }
  traverse(t2) {
    t2(this);
    for (const e2 of this.listChildren())
      e2.traverse(t2);
    return this;
  }
};
var ht = class extends H {
  init() {
    this.propertyType = p.PRIMITIVE;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), { mode: ht.Mode.TRIANGLES, material: null, indices: null, attributes: {}, targets: [] });
  }
  getIndices() {
    return this.getRef("indices");
  }
  setIndices(t2) {
    return this.setRef("indices", t2, { usage: w.ELEMENT_ARRAY_BUFFER });
  }
  getAttribute(t2) {
    return this.getRefMap("attributes", t2);
  }
  setAttribute(t2, e2) {
    return this.setRefMap("attributes", t2, e2, { usage: w.ARRAY_BUFFER });
  }
  listAttributes() {
    return this.listRefMapValues("attributes");
  }
  listSemantics() {
    return this.listRefMapKeys("attributes");
  }
  getMaterial() {
    return this.getRef("material");
  }
  setMaterial(t2) {
    return this.setRef("material", t2);
  }
  getMode() {
    return this.get("mode");
  }
  setMode(t2) {
    return this.set("mode", t2);
  }
  listTargets() {
    return this.listRefs("targets");
  }
  addTarget(t2) {
    return this.addRef("targets", t2);
  }
  removeTarget(t2) {
    return this.removeRef("targets", t2);
  }
};
ht.Mode = { POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6 };
var lt = class extends W {
  init() {
    this.propertyType = p.PRIMITIVE_TARGET;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), { attributes: {} });
  }
  getAttribute(t2) {
    return this.getRefMap("attributes", t2);
  }
  setAttribute(t2, e2) {
    return this.setRefMap("attributes", t2, e2, { usage: w.ARRAY_BUFFER });
  }
  listAttributes() {
    return this.listRefMapValues("attributes");
  }
  listSemantics() {
    return this.listRefMapKeys("attributes");
  }
};
function ft() {
  return (ft = Object.assign || function(t2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var r2 = arguments[e2];
      for (var s2 in r2)
        Object.prototype.hasOwnProperty.call(r2, s2) && (t2[s2] = r2[s2]);
    }
    return t2;
  }).apply(this, arguments);
}
var dt = class extends H {
  init() {
    this.propertyType = p.SCENE;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), { children: [] });
  }
  copy(t2, e2 = V) {
    if (e2 === V)
      throw new Error("Scene cannot be copied.");
    return super.copy(t2, e2);
  }
  addChild(t2) {
    t2.u && t2.u.removeChild(t2), this.addRef("children", t2), t2.u = this;
    const r2 = this[d].children;
    return r2[r2.length - 1].addEventListener("dispose", () => t2.u = null), this;
  }
  removeChild(t2) {
    return this.removeRef("children", t2);
  }
  listChildren() {
    return this.listRefs("children");
  }
  traverse(t2) {
    for (const e2 of this.listChildren())
      e2.traverse(t2);
    return this;
  }
};
var gt = class extends H {
  init() {
    this.propertyType = p.SKIN;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), { skeleton: null, inverseBindMatrices: null, joints: [] });
  }
  getSkeleton() {
    return this.getRef("skeleton");
  }
  setSkeleton(t2) {
    return this.setRef("skeleton", t2);
  }
  getInverseBindMatrices() {
    return this.getRef("inverseBindMatrices");
  }
  setInverseBindMatrices(t2) {
    return this.setRef("inverseBindMatrices", t2, { usage: w.INVERSE_BIND_MATRICES });
  }
  addJoint(t2) {
    return this.addRef("joints", t2);
  }
  removeJoint(t2) {
    return this.removeRef("joints", t2);
  }
  listJoints() {
    return this.listRefs("joints");
  }
};
var pt = class extends H {
  init() {
    this.propertyType = p.TEXTURE;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), { image: null, mimeType: "", uri: "" });
  }
  getMimeType() {
    return this.get("mimeType") || I.extensionToMimeType(N.extension(this.get("uri")));
  }
  setMimeType(t2) {
    return this.set("mimeType", t2);
  }
  getURI() {
    return this.get("uri");
  }
  setURI(t2) {
    return this.set("uri", t2), this.set("mimeType", I.extensionToMimeType(N.extension(t2))), this;
  }
  getImage() {
    return this.get("image");
  }
  setImage(t2) {
    return this.set("image", E.assertView(t2));
  }
  getSize() {
    const t2 = this.get("image");
    return t2 ? I.getSize(t2, this.getMimeType()) : null;
  }
};
var mt = class extends H {
  init() {
    this.propertyType = p.ROOT;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), { asset: { generator: "glTF-Transform v2.5.1", version: "2.0" }, defaultScene: null, accessors: [], animations: [], buffers: [], cameras: [], materials: [], meshes: [], nodes: [], scenes: [], skins: [], textures: [] });
  }
  constructor(t2) {
    super(t2), this.h = /* @__PURE__ */ new Set(), t2.addEventListener("node:create", (t3) => {
      this.l(t3.target);
    });
  }
  clone() {
    throw new Error("Root cannot be cloned.");
  }
  copy(t2, e2 = V) {
    if (e2 === V)
      throw new Error("Root cannot be copied.");
    this.set("asset", ft({}, t2.get("asset"))), this.setName(t2.getName()), this.setExtras(ft({}, t2.getExtras())), this.setDefaultScene(t2.getDefaultScene() ? e2(t2.getDefaultScene()) : null);
    for (const r2 of t2.listRefMapKeys("extensions")) {
      const s2 = t2.getExtension(r2);
      this.setExtension(r2, e2(s2));
    }
    return this;
  }
  l(t2) {
    return t2 instanceof dt ? this.addRef("scenes", t2) : t2 instanceof ct ? this.addRef("nodes", t2) : t2 instanceof tt ? this.addRef("cameras", t2) : t2 instanceof gt ? this.addRef("skins", t2) : t2 instanceof ut ? this.addRef("meshes", t2) : t2 instanceof at ? this.addRef("materials", t2) : t2 instanceof pt ? this.addRef("textures", t2) : t2 instanceof Z ? this.addRef("animations", t2) : t2 instanceof Y ? this.addRef("accessors", t2) : t2 instanceof X && this.addRef("buffers", t2), this;
  }
  getAsset() {
    return this.get("asset");
  }
  listExtensionsUsed() {
    return Array.from(this.h);
  }
  listExtensionsRequired() {
    return this.listExtensionsUsed().filter((t2) => t2.isRequired());
  }
  g(t2) {
    return this.h.add(t2), this;
  }
  p(t2) {
    return this.h.delete(t2), this;
  }
  listScenes() {
    return this.listRefs("scenes");
  }
  setDefaultScene(t2) {
    return this.setRef("defaultScene", t2);
  }
  getDefaultScene() {
    return this.getRef("defaultScene");
  }
  listNodes() {
    return this.listRefs("nodes");
  }
  listCameras() {
    return this.listRefs("cameras");
  }
  listSkins() {
    return this.listRefs("skins");
  }
  listMeshes() {
    return this.listRefs("meshes");
  }
  listMaterials() {
    return this.listRefs("materials");
  }
  listTextures() {
    return this.listRefs("textures");
  }
  listAnimations() {
    return this.listRefs("animations");
  }
  listAccessors() {
    return this.listRefs("accessors");
  }
  listBuffers() {
    return this.listRefs("buffers");
  }
};
var wt = class {
  constructor() {
    this.m = new s(), this.v = new mt(this.m), this.T = F.DEFAULT_INSTANCE;
  }
  getRoot() {
    return this.v;
  }
  getGraph() {
    return this.m;
  }
  getLogger() {
    return this.T;
  }
  setLogger(t2) {
    return this.T = t2, this;
  }
  clone() {
    return new wt().setLogger(this.T).merge(this);
  }
  merge(t2) {
    for (const e3 of t2.getRoot().listExtensionsUsed()) {
      const t3 = this.createExtension(e3.constructor);
      e3.isRequired() && t3.setRequired(true);
    }
    const e2 = /* @__PURE__ */ new Set(), r2 = /* @__PURE__ */ new Map();
    e2.add(t2.v), r2.set(t2.v, this.v);
    for (const s3 of t2.m.listEdges())
      for (const t3 of [s3.getParent(), s3.getChild()]) {
        if (e2.has(t3))
          continue;
        let s4;
        s4 = t3.propertyType === p.TEXTURE_INFO ? t3 : new (0, t3.constructor)(this.m), r2.set(t3, s4), e2.add(t3);
      }
    const s2 = (t3) => {
      const e3 = r2.get(t3);
      if (!e3)
        throw new Error("Could resolve property.");
      return e3;
    };
    for (const t3 of e2) {
      const e3 = r2.get(t3);
      if (!e3)
        throw new Error("Could resolve property.");
      e3.propertyType !== p.TEXTURE_INFO && e3.copy(t3, s2);
    }
    return this;
  }
  async transform(...t2) {
    const e2 = t2.map((t3) => t3.name);
    for (const r2 of t2)
      await r2(this, { stack: e2 });
    return this;
  }
  createExtension(t2) {
    const e2 = t2.EXTENSION_NAME;
    return this.getRoot().listExtensionsUsed().find((t3) => t3.extensionName === e2) || new t2(this);
  }
  createScene(t2 = "") {
    return new dt(this.m, t2);
  }
  createNode(t2 = "") {
    return new ct(this.m, t2);
  }
  createCamera(t2 = "") {
    return new tt(this.m, t2);
  }
  createSkin(t2 = "") {
    return new gt(this.m, t2);
  }
  createMesh(t2 = "") {
    return new ut(this.m, t2);
  }
  createPrimitive() {
    return new ht(this.m);
  }
  createPrimitiveTarget(t2 = "") {
    return new lt(this.m, t2);
  }
  createMaterial(t2 = "") {
    return new at(this.m, t2);
  }
  createTexture(t2 = "") {
    return new pt(this.m, t2);
  }
  createAnimation(t2 = "") {
    return new Z(this.m, t2);
  }
  createAnimationChannel(t2 = "") {
    return new K(this.m, t2);
  }
  createAnimationSampler(t2 = "") {
    return new Q(this.m, t2);
  }
  createAccessor(t2 = "", e2 = null) {
    return e2 || (e2 = this.getRoot().listBuffers()[0]), new Y(this.m, t2).setBuffer(e2);
  }
  createBuffer(t2 = "") {
    return new X(this.m, t2);
  }
};
var yt = class {
  constructor(t2) {
    this.extensionName = "", this.prereadTypes = [], this.prewriteTypes = [], this.readDependencies = [], this.writeDependencies = [], this.document = void 0, this.required = false, this.properties = /* @__PURE__ */ new Set(), this.S = void 0, this.document = t2, t2.getRoot().g(this), this.S = (t3) => {
      const e3 = t3, r2 = e3.target;
      r2 instanceof et && r2.extensionName === this.extensionName && ("node:create" === e3.type && this.M(r2), "node:dispose" === e3.type && this.I(r2));
    };
    const e2 = t2.getGraph();
    e2.addEventListener("node:create", this.S), e2.addEventListener("node:dispose", this.S);
  }
  dispose() {
    this.document.getRoot().p(this);
    const t2 = this.document.getGraph();
    t2.removeEventListener("node:create", this.S), t2.removeEventListener("node:dispose", this.S);
    for (const t3 of this.properties)
      t3.dispose();
  }
  static register() {
  }
  isRequired() {
    return this.required;
  }
  setRequired(t2) {
    return this.required = t2, this;
  }
  listProperties() {
    return Array.from(this.properties);
  }
  M(t2) {
    return this.properties.add(t2), this;
  }
  I(t2) {
    return this.properties.delete(t2), this;
  }
  install(t2, e2) {
    return this;
  }
  preread(t2, e2) {
    return this;
  }
  prewrite(t2, e2) {
    return this;
  }
};
yt.EXTENSION_NAME = void 0;
var vt = class {
  constructor(t2) {
    this.jsonDoc = void 0, this.buffers = [], this.bufferViews = [], this.bufferViewBuffers = [], this.accessors = [], this.textures = [], this.textureInfos = /* @__PURE__ */ new Map(), this.materials = [], this.meshes = [], this.cameras = [], this.nodes = [], this.skins = [], this.animations = [], this.scenes = [], this.jsonDoc = t2;
  }
  setTextureInfo(t2, e2) {
    this.textureInfos.set(t2, e2), void 0 !== e2.texCoord && t2.setTexCoord(e2.texCoord), void 0 !== e2.extras && t2.setExtras(e2.extras);
    const r2 = this.jsonDoc.json.textures[e2.index];
    if (void 0 === r2.sampler)
      return;
    const s2 = this.jsonDoc.json.samplers[r2.sampler];
    void 0 !== s2.magFilter && t2.setMagFilter(s2.magFilter), void 0 !== s2.minFilter && t2.setMinFilter(s2.minFilter), void 0 !== s2.wrapS && t2.setWrapS(s2.wrapS), void 0 !== s2.wrapT && t2.setWrapT(s2.wrapT);
  }
};
var Tt = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array };
var xt = { logger: F.DEFAULT_INSTANCE, extensions: [], dependencies: {} };
function bt(t2, e2) {
  const r2 = e2.bufferViews[t2.bufferView], s2 = e2.jsonDoc.json.bufferViews[t2.bufferView], n2 = Tt[t2.componentType], i2 = Y.getElementSize(t2.type), o2 = n2.BYTES_PER_ELEMENT;
  if (void 0 !== s2.byteStride && s2.byteStride !== i2 * o2)
    return function(t3, e3) {
      const r3 = e3.bufferViews[t3.bufferView], s3 = e3.jsonDoc.json.bufferViews[t3.bufferView], n3 = Tt[t3.componentType], i3 = Y.getElementSize(t3.type), o3 = n3.BYTES_PER_ELEMENT, a3 = t3.byteOffset || 0, u = new n3(t3.count * i3), c = new DataView(r3.buffer, r3.byteOffset, r3.byteLength), h2 = s3.byteStride;
      for (let e4 = 0; e4 < t3.count; e4++)
        for (let r4 = 0; r4 < i3; r4++) {
          const s4 = a3 + e4 * h2 + r4 * o3;
          let n4;
          switch (t3.componentType) {
            case Y.ComponentType.FLOAT:
              n4 = c.getFloat32(s4, true);
              break;
            case Y.ComponentType.UNSIGNED_INT:
              n4 = c.getUint32(s4, true);
              break;
            case Y.ComponentType.UNSIGNED_SHORT:
              n4 = c.getUint16(s4, true);
              break;
            case Y.ComponentType.UNSIGNED_BYTE:
              n4 = c.getUint8(s4);
              break;
            case Y.ComponentType.SHORT:
              n4 = c.getInt16(s4, true);
              break;
            case Y.ComponentType.BYTE:
              n4 = c.getInt8(s4);
              break;
            default:
              throw new Error(`Unexpected componentType "${t3.componentType}".`);
          }
          u[e4 * i3 + r4] = n4;
        }
      return u;
    }(t2, e2);
  const a2 = r2.byteOffset + (t2.byteOffset || 0);
  return new n2(r2.buffer.slice(a2, a2 + t2.count * i2 * o2));
}
var At;
!function(t2) {
  t2[t2.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", t2[t2.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER";
}(At || (At = {}));
var Et = class {
  constructor(t2, e2, r2) {
    this.N = void 0, this.jsonDoc = void 0, this.options = void 0, this.accessorIndexMap = /* @__PURE__ */ new Map(), this.animationIndexMap = /* @__PURE__ */ new Map(), this.bufferIndexMap = /* @__PURE__ */ new Map(), this.cameraIndexMap = /* @__PURE__ */ new Map(), this.skinIndexMap = /* @__PURE__ */ new Map(), this.materialIndexMap = /* @__PURE__ */ new Map(), this.meshIndexMap = /* @__PURE__ */ new Map(), this.nodeIndexMap = /* @__PURE__ */ new Map(), this.imageIndexMap = /* @__PURE__ */ new Map(), this.textureDefIndexMap = /* @__PURE__ */ new Map(), this.textureInfoDefMap = /* @__PURE__ */ new Map(), this.samplerDefIndexMap = /* @__PURE__ */ new Map(), this.sceneIndexMap = /* @__PURE__ */ new Map(), this.imageBufferViews = [], this.otherBufferViews = /* @__PURE__ */ new Map(), this.otherBufferViewsIndexMap = /* @__PURE__ */ new Map(), this.extensionData = {}, this.bufferURIGenerator = void 0, this.imageURIGenerator = void 0, this.logger = void 0, this.O = /* @__PURE__ */ new Map(), this.accessorUsageGroupedByParent = /* @__PURE__ */ new Set(["ARRAY_BUFFER"]), this.accessorParents = /* @__PURE__ */ new Map(), this.N = t2, this.jsonDoc = e2, this.options = r2;
    const s2 = t2.getRoot(), n2 = s2.listBuffers().length, i2 = s2.listTextures().length;
    this.bufferURIGenerator = new St(n2 > 1, () => r2.basename || "buffer"), this.imageURIGenerator = new St(i2 > 1, (e3) => function(t3, e4) {
      const r3 = t3.getGraph().listParentEdges(e4).find((e5) => e5.getParent() !== t3.getRoot());
      return r3 ? r3.getName().replace(/texture$/i, "") : "";
    }(t2, e3) || r2.basename || "texture"), this.logger = t2.getLogger();
  }
  createTextureInfoDef(t2, e2) {
    const r2 = { magFilter: e2.getMagFilter() || void 0, minFilter: e2.getMinFilter() || void 0, wrapS: e2.getWrapS(), wrapT: e2.getWrapT() }, s2 = JSON.stringify(r2);
    this.samplerDefIndexMap.has(s2) || (this.samplerDefIndexMap.set(s2, this.jsonDoc.json.samplers.length), this.jsonDoc.json.samplers.push(r2));
    const n2 = { source: this.imageIndexMap.get(t2), sampler: this.samplerDefIndexMap.get(s2) }, i2 = JSON.stringify(n2);
    this.textureDefIndexMap.has(i2) || (this.textureDefIndexMap.set(i2, this.jsonDoc.json.textures.length), this.jsonDoc.json.textures.push(n2));
    const o2 = { index: this.textureDefIndexMap.get(i2) };
    return 0 !== e2.getTexCoord() && (o2.texCoord = e2.getTexCoord()), Object.keys(e2.getExtras()).length > 0 && (o2.extras = e2.getExtras()), this.textureInfoDefMap.set(e2, o2), o2;
  }
  createPropertyDef(t2) {
    const e2 = {};
    return t2.getName() && (e2.name = t2.getName()), Object.keys(t2.getExtras()).length > 0 && (e2.extras = t2.getExtras()), e2;
  }
  createAccessorDef(t2) {
    const e2 = this.createPropertyDef(t2);
    return e2.type = t2.getType(), e2.componentType = t2.getComponentType(), e2.count = t2.getCount(), this.N.getGraph().listParentEdges(t2).some((t3) => "attributes" === t3.getName() && "POSITION" === t3.getAttributes().key || "input" === t3.getName()) && (e2.max = t2.getMax([]).map(Math.fround), e2.min = t2.getMin([]).map(Math.fround)), t2.getNormalized() && (e2.normalized = t2.getNormalized()), e2;
  }
  createImageData(t2, e2, r2) {
    if (this.options.format === v.GLB)
      this.imageBufferViews.push(e2), t2.bufferView = this.jsonDoc.json.bufferViews.length, this.jsonDoc.json.bufferViews.push({ buffer: 0, byteOffset: -1, byteLength: e2.byteLength });
    else {
      const s2 = I.mimeTypeToExtension(r2.getMimeType());
      t2.uri = this.imageURIGenerator.createURI(r2, s2), this.jsonDoc.resources[t2.uri] = e2;
    }
  }
  getAccessorUsage(t2) {
    const e2 = this.O.get(t2);
    if (e2)
      return e2;
    for (const e3 of this.N.getGraph().listParentEdges(t2)) {
      const { usage: t3 } = e3.getAttributes();
      if (t3)
        return t3;
      e3.getParent().propertyType !== p.ROOT && this.N.getLogger().warn(`Missing attribute ".usage" on edge, "${e3.getName()}".`);
    }
    return Et.BufferViewUsage.OTHER;
  }
  addAccessorToUsageGroup(t2, e2) {
    const r2 = this.O.get(t2);
    if (r2 && r2 !== e2)
      throw new Error(`Accessor with usage "${r2}" cannot be reused as "${e2}".`);
    return this.O.set(t2, e2), this;
  }
  listAccessorUsageGroups() {
    const t2 = {};
    for (const [e2, r2] of Array.from(this.O.entries()))
      t2[r2] = t2[r2] || [], t2[r2].push(e2);
    return t2;
  }
};
Et.BufferViewTarget = At, Et.BufferViewUsage = w, Et.USAGE_TO_TARGET = { [w.ARRAY_BUFFER]: At.ARRAY_BUFFER, [w.ELEMENT_ARRAY_BUFFER]: At.ELEMENT_ARRAY_BUFFER };
var St = class {
  constructor(t2, e2) {
    this.multiple = void 0, this.basename = void 0, this.counter = {}, this.multiple = t2, this.basename = e2;
  }
  createURI(t2, e2) {
    if (t2.getURI())
      return t2.getURI();
    if (this.multiple) {
      const r2 = this.basename(t2);
      return this.counter[r2] = this.counter[r2] || 1, `${r2}_${this.counter[r2]++}.${e2}`;
    }
    return `${this.basename(t2)}.${e2}`;
  }
};
var { BufferViewUsage: Mt } = Et;
var It;
!function(t2) {
  t2[t2.JSON = 1313821514] = "JSON", t2[t2.BIN = 5130562] = "BIN";
}(It || (It = {}));
var Rt = class {
  constructor() {
    this.T = F.DEFAULT_INSTANCE, this.h = /* @__PURE__ */ new Set(), this.C = {}, this.F = m.INTERLEAVED, this.lastReadBytes = 0, this.lastWriteBytes = 0;
  }
  setLogger(t2) {
    return this.T = t2, this;
  }
  registerExtensions(t2) {
    for (const e2 of t2)
      this.h.add(e2), e2.register();
    return this;
  }
  registerDependencies(t2) {
    return Object.assign(this.C, t2), this;
  }
  setVertexLayout(t2) {
    return this.F = t2, this;
  }
  async read(t2) {
    return await this.readJSON(await this.readAsJSON(t2));
  }
  async readAsJSON(t2) {
    return t2.match(/^data:application\/octet-stream;/) || this.detectFormat(t2) === v.GLB ? this.P(t2) : this.U(t2);
  }
  async readJSON(t2) {
    return t2 = this.j(t2), this.L(t2), class {
      static read(t3, e2 = xt) {
        const r2 = ft({}, xt, e2), { json: s2 } = t3, n2 = new wt();
        this.validate(t3, r2);
        const i2 = new vt(t3), o2 = s2.asset, a2 = n2.getRoot().getAsset();
        o2.copyright && (a2.copyright = o2.copyright), o2.extras && (a2.extras = o2.extras), void 0 !== s2.extras && n2.getRoot().setExtras(ft({}, s2.extras));
        const u = s2.extensionsUsed || [], c = s2.extensionsRequired || [];
        for (const t4 of r2.extensions)
          if (u.includes(t4.EXTENSION_NAME)) {
            const e3 = n2.createExtension(t4).setRequired(c.includes(t4.EXTENSION_NAME));
            for (const t5 of e3.readDependencies)
              e3.install(t5, r2.dependencies[t5]);
          }
        const h2 = s2.buffers || [];
        n2.getRoot().listExtensionsUsed().filter((t4) => t4.prereadTypes.includes(p.BUFFER)).forEach((t4) => t4.preread(i2, p.BUFFER)), i2.buffers = h2.map((t4) => {
          const e3 = n2.createBuffer(t4.name);
          return t4.extras && e3.setExtras(t4.extras), t4.uri && 0 !== t4.uri.indexOf("__") && e3.setURI(t4.uri), e3;
        }), i2.bufferViewBuffers = (s2.bufferViews || []).map((e3, r3) => {
          if (!i2.bufferViews[r3]) {
            const s3 = t3.json.buffers[e3.buffer];
            i2.bufferViews[r3] = E.toView(s3.uri ? t3.resources[s3.uri] : t3.resources["@glb.bin"], e3.byteOffset || 0, e3.byteLength);
          }
          return i2.buffers[e3.buffer];
        }), i2.accessors = (s2.accessors || []).map((t4) => {
          const e3 = n2.createAccessor(t4.name, i2.bufferViewBuffers[t4.bufferView]).setType(t4.type);
          if (t4.extras && e3.setExtras(t4.extras), void 0 !== t4.normalized && e3.setNormalized(t4.normalized), void 0 === t4.bufferView && !t4.sparse)
            return e3;
          let r3;
          return r3 = void 0 !== t4.sparse ? function(t5, e4) {
            const r4 = Tt[t5.componentType], s3 = Y.getElementSize(t5.type);
            let n3;
            n3 = void 0 !== t5.bufferView ? bt(t5, e4) : new r4(t5.count * s3);
            const i3 = t5.sparse, o3 = i3.count, a3 = ft({}, t5, i3.indices, { count: o3, type: "SCALAR" }), u2 = ft({}, t5, i3.values, { count: o3 }), c2 = bt(a3, e4), h3 = bt(u2, e4);
            for (let t6 = 0; t6 < a3.count; t6++)
              for (let e5 = 0; e5 < s3; e5++)
                n3[c2[t6] * s3 + e5] = h3[t6 * s3 + e5];
            return n3;
          }(t4, i2) : bt(t4, i2), e3.setArray(r3), e3;
        });
        const l = s2.images || [], f = s2.textures || [];
        n2.getRoot().listExtensionsUsed().filter((t4) => t4.prereadTypes.includes(p.TEXTURE)).forEach((t4) => t4.preread(i2, p.TEXTURE)), i2.textures = l.map((e3) => {
          const r3 = n2.createTexture(e3.name);
          if (e3.extras && r3.setExtras(e3.extras), void 0 !== e3.bufferView) {
            const n3 = s2.bufferViews[e3.bufferView], i3 = t3.json.buffers[n3.buffer], o3 = n3.byteOffset || 0, a3 = (i3.uri ? t3.resources[i3.uri] : t3.resources["@glb.bin"]).slice(o3, o3 + n3.byteLength);
            r3.setImage(a3);
          } else
            void 0 !== e3.uri && (r3.setImage(t3.resources[e3.uri]), 0 !== e3.uri.indexOf("__") && r3.setURI(e3.uri));
          if (void 0 !== e3.mimeType)
            r3.setMimeType(e3.mimeType);
          else if (e3.uri) {
            const t4 = N.extension(e3.uri);
            r3.setMimeType(I.extensionToMimeType(t4));
          }
          return r3;
        }), i2.materials = (s2.materials || []).map((t4) => {
          const e3 = n2.createMaterial(t4.name);
          t4.extras && e3.setExtras(t4.extras), void 0 !== t4.alphaMode && e3.setAlphaMode(t4.alphaMode), void 0 !== t4.alphaCutoff && e3.setAlphaCutoff(t4.alphaCutoff), void 0 !== t4.doubleSided && e3.setDoubleSided(t4.doubleSided);
          const r3 = t4.pbrMetallicRoughness || {};
          if (void 0 !== r3.baseColorFactor && e3.setBaseColorFactor(r3.baseColorFactor), void 0 !== t4.emissiveFactor && e3.setEmissiveFactor(t4.emissiveFactor), void 0 !== r3.metallicFactor && e3.setMetallicFactor(r3.metallicFactor), void 0 !== r3.roughnessFactor && e3.setRoughnessFactor(r3.roughnessFactor), void 0 !== r3.baseColorTexture) {
            const t5 = r3.baseColorTexture;
            e3.setBaseColorTexture(i2.textures[f[t5.index].source]), i2.setTextureInfo(e3.getBaseColorTextureInfo(), t5);
          }
          if (void 0 !== t4.emissiveTexture) {
            const r4 = t4.emissiveTexture;
            e3.setEmissiveTexture(i2.textures[f[r4.index].source]), i2.setTextureInfo(e3.getEmissiveTextureInfo(), r4);
          }
          if (void 0 !== t4.normalTexture) {
            const r4 = t4.normalTexture;
            e3.setNormalTexture(i2.textures[f[r4.index].source]), i2.setTextureInfo(e3.getNormalTextureInfo(), r4), void 0 !== t4.normalTexture.scale && e3.setNormalScale(t4.normalTexture.scale);
          }
          if (void 0 !== t4.occlusionTexture) {
            const r4 = t4.occlusionTexture;
            e3.setOcclusionTexture(i2.textures[f[r4.index].source]), i2.setTextureInfo(e3.getOcclusionTextureInfo(), r4), void 0 !== t4.occlusionTexture.strength && e3.setOcclusionStrength(t4.occlusionTexture.strength);
          }
          if (void 0 !== r3.metallicRoughnessTexture) {
            const t5 = r3.metallicRoughnessTexture;
            e3.setMetallicRoughnessTexture(i2.textures[f[t5.index].source]), i2.setTextureInfo(e3.getMetallicRoughnessTextureInfo(), t5);
          }
          return e3;
        });
        const d3 = s2.meshes || [];
        n2.getRoot().listExtensionsUsed().filter((t4) => t4.prereadTypes.includes(p.PRIMITIVE)).forEach((t4) => t4.preread(i2, p.PRIMITIVE)), i2.meshes = d3.map((t4) => {
          const e3 = n2.createMesh(t4.name);
          return t4.extras && e3.setExtras(t4.extras), void 0 !== t4.weights && e3.setWeights(t4.weights), (t4.primitives || []).forEach((r3) => {
            const s3 = n2.createPrimitive();
            r3.extras && s3.setExtras(r3.extras), void 0 !== r3.material && s3.setMaterial(i2.materials[r3.material]), void 0 !== r3.mode && s3.setMode(r3.mode);
            for (const [t5, e4] of Object.entries(r3.attributes || {}))
              s3.setAttribute(t5, i2.accessors[e4]);
            void 0 !== r3.indices && s3.setIndices(i2.accessors[r3.indices]);
            const o3 = t4.extras && t4.extras.targetNames || [];
            (r3.targets || []).forEach((t5, e4) => {
              const r4 = o3[e4] || e4.toString(), a3 = n2.createPrimitiveTarget(r4);
              for (const [e5, r5] of Object.entries(t5))
                a3.setAttribute(e5, i2.accessors[r5]);
              s3.addTarget(a3);
            }), e3.addPrimitive(s3);
          }), e3;
        }), i2.cameras = (s2.cameras || []).map((t4) => {
          const e3 = n2.createCamera(t4.name).setType(t4.type);
          if (t4.extras && e3.setExtras(t4.extras), t4.type === tt.Type.PERSPECTIVE) {
            const r3 = t4.perspective;
            e3.setYFov(r3.yfov), e3.setZNear(r3.znear), void 0 !== r3.zfar && e3.setZFar(r3.zfar), void 0 !== r3.aspectRatio && e3.setAspectRatio(r3.aspectRatio);
          } else {
            const r3 = t4.orthographic;
            e3.setZNear(r3.znear).setZFar(r3.zfar).setXMag(r3.xmag).setYMag(r3.ymag);
          }
          return e3;
        });
        const g2 = s2.nodes || [];
        n2.getRoot().listExtensionsUsed().filter((t4) => t4.prereadTypes.includes(p.NODE)).forEach((t4) => t4.preread(i2, p.NODE)), i2.nodes = g2.map((t4) => {
          const e3 = n2.createNode(t4.name);
          if (t4.extras && e3.setExtras(t4.extras), void 0 !== t4.translation && e3.setTranslation(t4.translation), void 0 !== t4.rotation && e3.setRotation(t4.rotation), void 0 !== t4.scale && e3.setScale(t4.scale), void 0 !== t4.matrix) {
            const r3 = [0, 0, 0], s3 = [0, 0, 0, 1], n3 = [1, 1, 1];
            B.decompose(t4.matrix, r3, s3, n3), e3.setTranslation(r3), e3.setRotation(s3), e3.setScale(n3);
          }
          return void 0 !== t4.weights && e3.setWeights(t4.weights), e3;
        }), i2.skins = (s2.skins || []).map((t4) => {
          const e3 = n2.createSkin(t4.name);
          t4.extras && e3.setExtras(t4.extras), void 0 !== t4.inverseBindMatrices && e3.setInverseBindMatrices(i2.accessors[t4.inverseBindMatrices]), void 0 !== t4.skeleton && e3.setSkeleton(i2.nodes[t4.skeleton]);
          for (const r3 of t4.joints)
            e3.addJoint(i2.nodes[r3]);
          return e3;
        }), g2.map((t4, e3) => {
          const r3 = i2.nodes[e3];
          (t4.children || []).forEach((t5) => r3.addChild(i2.nodes[t5])), void 0 !== t4.mesh && r3.setMesh(i2.meshes[t4.mesh]), void 0 !== t4.camera && r3.setCamera(i2.cameras[t4.camera]), void 0 !== t4.skin && r3.setSkin(i2.skins[t4.skin]);
        }), i2.animations = (s2.animations || []).map((t4) => {
          const e3 = n2.createAnimation(t4.name);
          t4.extras && e3.setExtras(t4.extras);
          const r3 = (t4.samplers || []).map((t5) => {
            const r4 = n2.createAnimationSampler().setInput(i2.accessors[t5.input]).setOutput(i2.accessors[t5.output]).setInterpolation(t5.interpolation || Q.Interpolation.LINEAR);
            return t5.extras && r4.setExtras(t5.extras), e3.addSampler(r4), r4;
          });
          return (t4.channels || []).forEach((t5) => {
            const s3 = n2.createAnimationChannel().setSampler(r3[t5.sampler]).setTargetPath(t5.target.path);
            void 0 !== t5.target.node && s3.setTargetNode(i2.nodes[t5.target.node]), t5.extras && s3.setExtras(t5.extras), e3.addChannel(s3);
          }), e3;
        });
        const m2 = s2.scenes || [];
        return n2.getRoot().listExtensionsUsed().filter((t4) => t4.prereadTypes.includes(p.SCENE)).forEach((t4) => t4.preread(i2, p.SCENE)), i2.scenes = m2.map((t4) => {
          const e3 = n2.createScene(t4.name);
          return t4.extras && e3.setExtras(t4.extras), (t4.nodes || []).map((t5) => i2.nodes[t5]).forEach((t5) => e3.addChild(t5)), e3;
        }), void 0 !== s2.scene && n2.getRoot().setDefaultScene(i2.scenes[s2.scene]), n2.getRoot().listExtensionsUsed().forEach((t4) => t4.read(i2)), n2;
      }
      static validate(t3, e2) {
        const r2 = t3.json;
        if ("2.0" !== r2.asset.version)
          throw new Error(`Unsupported glTF version, "${r2.asset.version}".`);
        if (r2.extensionsRequired) {
          for (const t4 of r2.extensionsRequired)
            if (!e2.extensions.find((e3) => e3.EXTENSION_NAME === t4))
              throw new Error(`Missing required extension, "${t4}".`);
        }
        if (r2.extensionsUsed)
          for (const t4 of r2.extensionsUsed)
            e2.extensions.find((e3) => e3.EXTENSION_NAME === t4) || e2.logger.warn(`Missing optional extension, "${t4}".`);
      }
    }.read(t2, { extensions: Array.from(this.h), dependencies: this.C, logger: this.T });
  }
  async binaryToJSON(t2) {
    const e2 = this._(E.assertView(t2));
    this.L(e2);
    const r2 = e2.json;
    if (r2.buffers && r2.buffers.some((t3) => function(t4, e3) {
      return void 0 !== e3.uri && !(e3.uri in t4.resources);
    }(e2, t3)))
      throw new Error("Cannot resolve external buffers with binaryToJSON().");
    if (r2.images && r2.images.some((t3) => function(t4, e3) {
      return void 0 !== e3.uri && !(e3.uri in t4.resources) && void 0 === e3.bufferView;
    }(e2, t3)))
      throw new Error("Cannot resolve external images with binaryToJSON().");
    return e2;
  }
  async readBinary(t2) {
    return this.readJSON(await this.binaryToJSON(E.assertView(t2)));
  }
  async writeJSON(t2, e2 = {}) {
    if (e2.format === v.GLB && t2.getRoot().listBuffers().length > 1)
      throw new Error("GLB must have 01 buffers.");
    return class {
      static write(t3, e3) {
        const r2 = t3.getRoot(), s2 = { asset: ft({ generator: "glTF-Transform v2.5.1" }, r2.getAsset()), extras: ft({}, r2.getExtras()) }, n2 = { json: s2, resources: {} }, i2 = new Et(t3, n2, e3), o2 = e3.logger || F.DEFAULT_INSTANCE, a2 = new Set(e3.extensions.map((t4) => t4.EXTENSION_NAME)), u = t3.getRoot().listExtensionsUsed().filter((t4) => a2.has(t4.extensionName)), c = t3.getRoot().listExtensionsRequired().filter((t4) => a2.has(t4.extensionName));
        u.length < t3.getRoot().listExtensionsUsed().length && o2.warn("Some extensions were not registered for I/O, and will not be written.");
        for (const t4 of u)
          for (const r3 of t4.writeDependencies)
            t4.install(r3, e3.dependencies[r3]);
        function h2(t4, e4, r3, n3) {
          const o3 = [];
          let a3 = 0;
          for (const e5 of t4) {
            const t5 = i2.createAccessorDef(e5);
            t5.bufferView = s2.bufferViews.length;
            const r4 = e5.getArray(), n4 = E.pad(E.toView(r4));
            t5.byteOffset = a3, a3 += n4.byteLength, o3.push(n4), i2.accessorIndexMap.set(e5, s2.accessors.length), s2.accessors.push(t5);
          }
          const u2 = { buffer: e4, byteOffset: r3, byteLength: E.concat(o3).byteLength };
          return n3 && (u2.target = n3), s2.bufferViews.push(u2), { buffers: o3, byteLength: a3 };
        }
        function l(t4, e4, r3) {
          const n3 = t4[0].getCount();
          let o3 = 0;
          for (const e5 of t4) {
            const t5 = i2.createAccessorDef(e5);
            t5.bufferView = s2.bufferViews.length, t5.byteOffset = o3;
            const r4 = e5.getElementSize(), n4 = e5.getComponentSize();
            o3 += E.padNumber(r4 * n4), i2.accessorIndexMap.set(e5, s2.accessors.length), s2.accessors.push(t5);
          }
          const a3 = n3 * o3, u2 = new ArrayBuffer(a3), c2 = new DataView(u2);
          for (let e5 = 0; e5 < n3; e5++) {
            let r4 = 0;
            for (const s3 of t4) {
              const t5 = s3.getElementSize(), n4 = s3.getComponentSize(), i3 = s3.getComponentType(), a4 = s3.getArray();
              for (let s4 = 0; s4 < t5; s4++) {
                const u3 = e5 * o3 + r4 + s4 * n4, h3 = a4[e5 * t5 + s4];
                switch (i3) {
                  case Y.ComponentType.FLOAT:
                    c2.setFloat32(u3, h3, true);
                    break;
                  case Y.ComponentType.BYTE:
                    c2.setInt8(u3, h3);
                    break;
                  case Y.ComponentType.SHORT:
                    c2.setInt16(u3, h3, true);
                    break;
                  case Y.ComponentType.UNSIGNED_BYTE:
                    c2.setUint8(u3, h3);
                    break;
                  case Y.ComponentType.UNSIGNED_SHORT:
                    c2.setUint16(u3, h3, true);
                    break;
                  case Y.ComponentType.UNSIGNED_INT:
                    c2.setUint32(u3, h3, true);
                    break;
                  default:
                    throw new Error("Unexpected component type: " + i3);
                }
              }
              r4 += E.padNumber(t5 * n4);
            }
          }
          return s2.bufferViews.push({ buffer: e4, byteOffset: r3, byteLength: a3, byteStride: o3, target: Et.BufferViewTarget.ARRAY_BUFFER }), { byteLength: a3, buffers: [new Uint8Array(u2)] };
        }
        const f = /* @__PURE__ */ new Map();
        for (const e4 of t3.getGraph().listEdges()) {
          if (e4.getParent() === r2)
            continue;
          const t4 = e4.getChild();
          if (t4 instanceof Y) {
            const r3 = f.get(t4) || [];
            r3.push(e4), f.set(t4, r3);
          }
        }
        if (s2.accessors = [], s2.bufferViews = [], s2.samplers = [], s2.textures = [], s2.images = r2.listTextures().map((t4, e4) => {
          const r3 = i2.createPropertyDef(t4);
          t4.getMimeType() && (r3.mimeType = t4.getMimeType());
          const s3 = t4.getImage();
          return s3 && i2.createImageData(r3, s3, t4), i2.imageIndexMap.set(t4, e4), r3;
        }), u.filter((t4) => t4.prewriteTypes.includes(p.ACCESSOR)).forEach((t4) => t4.prewrite(i2, p.ACCESSOR)), r2.listAccessors().forEach((t4) => {
          const e4 = i2.accessorUsageGroupedByParent, r3 = i2.accessorParents;
          if (i2.accessorIndexMap.has(t4))
            return;
          const s3 = f.get(t4) || [], n3 = i2.getAccessorUsage(t4);
          if (i2.addAccessorToUsageGroup(t4, n3), e4.has(n3)) {
            const e5 = s3[0].getParent(), n4 = r3.get(e5) || /* @__PURE__ */ new Set();
            n4.add(t4), r3.set(e5, n4);
          }
        }), u.filter((t4) => t4.prewriteTypes.includes(p.BUFFER)).forEach((t4) => t4.prewrite(i2, p.BUFFER)), (r2.listAccessors().length > 0 || r2.listTextures().length > 0 || i2.otherBufferViews.size > 0) && 0 === r2.listBuffers().length)
          throw new Error("Buffer required for Document resources, but none was found.");
        s2.buffers = [], r2.listBuffers().forEach((t4, r3) => {
          const o3 = i2.createPropertyDef(t4), a3 = i2.accessorUsageGroupedByParent, u2 = i2.accessorParents, c2 = t4.listParents().filter((t5) => t5 instanceof Y), f2 = new Set(c2), d4 = [], g2 = s2.buffers.length;
          let p2 = 0;
          const w2 = i2.listAccessorUsageGroups();
          for (const t5 in w2)
            if (a3.has(t5))
              for (const r4 of Array.from(u2.values())) {
                const s3 = Array.from(r4).filter((t6) => f2.has(t6)).filter((e4) => i2.getAccessorUsage(e4) === t5);
                if (s3.length)
                  if (t5 !== Mt.ARRAY_BUFFER || e3.vertexLayout === m.INTERLEAVED) {
                    const e4 = t5 === Mt.ARRAY_BUFFER ? l(s3, g2, p2) : h2(s3, g2, p2);
                    p2 += e4.byteLength, d4.push(...e4.buffers);
                  } else
                    for (const t6 of s3) {
                      const e4 = l([t6], g2, p2);
                      p2 += e4.byteLength, d4.push(...e4.buffers);
                    }
              }
            else {
              const e4 = w2[t5].filter((t6) => f2.has(t6));
              if (!e4.length)
                continue;
              const r4 = h2(e4, g2, p2, t5 === Mt.ELEMENT_ARRAY_BUFFER ? Et.BufferViewTarget.ELEMENT_ARRAY_BUFFER : void 0);
              p2 += r4.byteLength, d4.push(...r4.buffers);
            }
          if (i2.imageBufferViews.length && 0 === r3) {
            for (let t5 = 0; t5 < i2.imageBufferViews.length; t5++)
              if (s2.bufferViews[s2.images[t5].bufferView].byteOffset = p2, p2 += i2.imageBufferViews[t5].byteLength, d4.push(i2.imageBufferViews[t5]), p2 % 8) {
                const t6 = 8 - p2 % 8;
                p2 += t6, d4.push(new Uint8Array(t6));
              }
          }
          if (i2.otherBufferViews.has(t4))
            for (const e4 of i2.otherBufferViews.get(t4))
              s2.bufferViews.push({ buffer: g2, byteOffset: p2, byteLength: e4.byteLength }), i2.otherBufferViewsIndexMap.set(e4, s2.bufferViews.length - 1), p2 += e4.byteLength, d4.push(e4);
          if (p2) {
            let r4;
            e3.format === v.GLB ? r4 = "@glb.bin" : (r4 = i2.bufferURIGenerator.createURI(t4, "bin"), o3.uri = r4), o3.byteLength = p2, n2.resources[r4] = E.concat(d4);
          }
          s2.buffers.push(o3), i2.bufferIndexMap.set(t4, r3);
        }), r2.listAccessors().find((t4) => !t4.getBuffer()) && o2.warn("Skipped writing one or more Accessors: no Buffer assigned."), s2.materials = r2.listMaterials().map((t4, e4) => {
          const r3 = i2.createPropertyDef(t4);
          if (t4.getAlphaMode() !== at.AlphaMode.OPAQUE && (r3.alphaMode = t4.getAlphaMode()), t4.getAlphaMode() === at.AlphaMode.MASK && (r3.alphaCutoff = t4.getAlphaCutoff()), t4.getDoubleSided() && (r3.doubleSided = true), r3.pbrMetallicRoughness = {}, B.eq(t4.getBaseColorFactor(), [1, 1, 1, 1]) || (r3.pbrMetallicRoughness.baseColorFactor = t4.getBaseColorFactor()), B.eq(t4.getEmissiveFactor(), [0, 0, 0]) || (r3.emissiveFactor = t4.getEmissiveFactor()), 1 !== t4.getRoughnessFactor() && (r3.pbrMetallicRoughness.roughnessFactor = t4.getRoughnessFactor()), 1 !== t4.getMetallicFactor() && (r3.pbrMetallicRoughness.metallicFactor = t4.getMetallicFactor()), t4.getBaseColorTexture()) {
            const e5 = t4.getBaseColorTexture(), s3 = t4.getBaseColorTextureInfo();
            r3.pbrMetallicRoughness.baseColorTexture = i2.createTextureInfoDef(e5, s3);
          }
          if (t4.getEmissiveTexture()) {
            const e5 = t4.getEmissiveTexture(), s3 = t4.getEmissiveTextureInfo();
            r3.emissiveTexture = i2.createTextureInfoDef(e5, s3);
          }
          if (t4.getNormalTexture()) {
            const e5 = t4.getNormalTexture(), s3 = t4.getNormalTextureInfo(), n3 = i2.createTextureInfoDef(e5, s3);
            1 !== t4.getNormalScale() && (n3.scale = t4.getNormalScale()), r3.normalTexture = n3;
          }
          if (t4.getOcclusionTexture()) {
            const e5 = t4.getOcclusionTexture(), s3 = t4.getOcclusionTextureInfo(), n3 = i2.createTextureInfoDef(e5, s3);
            1 !== t4.getOcclusionStrength() && (n3.strength = t4.getOcclusionStrength()), r3.occlusionTexture = n3;
          }
          if (t4.getMetallicRoughnessTexture()) {
            const e5 = t4.getMetallicRoughnessTexture(), s3 = t4.getMetallicRoughnessTextureInfo();
            r3.pbrMetallicRoughness.metallicRoughnessTexture = i2.createTextureInfoDef(e5, s3);
          }
          return i2.materialIndexMap.set(t4, e4), r3;
        }), s2.meshes = r2.listMeshes().map((t4, e4) => {
          const r3 = i2.createPropertyDef(t4);
          let s3 = null;
          return r3.primitives = t4.listPrimitives().map((t5) => {
            const e5 = { attributes: {} };
            e5.mode = t5.getMode();
            const r4 = t5.getMaterial();
            r4 && (e5.material = i2.materialIndexMap.get(r4)), Object.keys(t5.getExtras()).length && (e5.extras = t5.getExtras());
            const n3 = t5.getIndices();
            n3 && (e5.indices = i2.accessorIndexMap.get(n3));
            for (const r5 of t5.listSemantics())
              e5.attributes[r5] = i2.accessorIndexMap.get(t5.getAttribute(r5));
            for (const r5 of t5.listTargets()) {
              const t6 = {};
              for (const e6 of r5.listSemantics())
                t6[e6] = i2.accessorIndexMap.get(r5.getAttribute(e6));
              e5.targets = e5.targets || [], e5.targets.push(t6);
            }
            return t5.listTargets().length && !s3 && (s3 = t5.listTargets().map((t6) => t6.getName())), e5;
          }), t4.getWeights().length && (r3.weights = t4.getWeights()), s3 && (r3.extras = r3.extras || {}, r3.extras.targetNames = s3), i2.meshIndexMap.set(t4, e4), r3;
        }), s2.cameras = r2.listCameras().map((t4, e4) => {
          const r3 = i2.createPropertyDef(t4);
          if (r3.type = t4.getType(), r3.type === tt.Type.PERSPECTIVE) {
            r3.perspective = { znear: t4.getZNear(), zfar: t4.getZFar(), yfov: t4.getYFov() };
            const e5 = t4.getAspectRatio();
            null !== e5 && (r3.perspective.aspectRatio = e5);
          } else
            r3.orthographic = { znear: t4.getZNear(), zfar: t4.getZFar(), xmag: t4.getXMag(), ymag: t4.getYMag() };
          return i2.cameraIndexMap.set(t4, e4), r3;
        }), s2.nodes = r2.listNodes().map((t4, e4) => {
          const r3 = i2.createPropertyDef(t4);
          return B.eq(t4.getTranslation(), [0, 0, 0]) || (r3.translation = t4.getTranslation()), B.eq(t4.getRotation(), [0, 0, 0, 1]) || (r3.rotation = t4.getRotation()), B.eq(t4.getScale(), [1, 1, 1]) || (r3.scale = t4.getScale()), t4.getWeights().length && (r3.weights = t4.getWeights()), i2.nodeIndexMap.set(t4, e4), r3;
        }), s2.skins = r2.listSkins().map((t4, e4) => {
          const r3 = i2.createPropertyDef(t4), s3 = t4.getInverseBindMatrices();
          s3 && (r3.inverseBindMatrices = i2.accessorIndexMap.get(s3));
          const n3 = t4.getSkeleton();
          return n3 && (r3.skeleton = i2.nodeIndexMap.get(n3)), r3.joints = t4.listJoints().map((t5) => i2.nodeIndexMap.get(t5)), i2.skinIndexMap.set(t4, e4), r3;
        }), r2.listNodes().forEach((t4, e4) => {
          const r3 = s2.nodes[e4], n3 = t4.getMesh();
          n3 && (r3.mesh = i2.meshIndexMap.get(n3));
          const o3 = t4.getCamera();
          o3 && (r3.camera = i2.cameraIndexMap.get(o3));
          const a3 = t4.getSkin();
          a3 && (r3.skin = i2.skinIndexMap.get(a3)), t4.listChildren().length > 0 && (r3.children = t4.listChildren().map((t5) => i2.nodeIndexMap.get(t5)));
        }), s2.animations = r2.listAnimations().map((t4, e4) => {
          const r3 = i2.createPropertyDef(t4), s3 = /* @__PURE__ */ new Map();
          return r3.samplers = t4.listSamplers().map((t5, e5) => {
            const r4 = i2.createPropertyDef(t5);
            return r4.input = i2.accessorIndexMap.get(t5.getInput()), r4.output = i2.accessorIndexMap.get(t5.getOutput()), r4.interpolation = t5.getInterpolation(), s3.set(t5, e5), r4;
          }), r3.channels = t4.listChannels().map((t5) => {
            const e5 = i2.createPropertyDef(t5);
            return e5.sampler = s3.get(t5.getSampler()), e5.target = { node: i2.nodeIndexMap.get(t5.getTargetNode()), path: t5.getTargetPath() }, e5;
          }), i2.animationIndexMap.set(t4, e4), r3;
        }), s2.scenes = r2.listScenes().map((t4, e4) => {
          const r3 = i2.createPropertyDef(t4);
          return r3.nodes = t4.listChildren().map((t5) => i2.nodeIndexMap.get(t5)), i2.sceneIndexMap.set(t4, e4), r3;
        });
        const d3 = r2.getDefaultScene();
        return d3 && (s2.scene = r2.listScenes().indexOf(d3)), s2.extensionsUsed = u.map((t4) => t4.extensionName), s2.extensionsRequired = c.map((t4) => t4.extensionName), u.forEach((t4) => t4.write(i2)), function(t4) {
          const e4 = [];
          for (const r3 in t4) {
            const s3 = t4[r3];
            (Array.isArray(s3) && 0 === s3.length || null === s3 || "" === s3 || s3 && "object" == typeof s3 && 0 === Object.keys(s3).length) && e4.push(r3);
          }
          for (const r3 of e4)
            delete t4[r3];
        }(s2), n2;
      }
    }.write(t2, { format: e2.format || v.GLTF, basename: e2.basename || "", logger: this.T, vertexLayout: this.F, dependencies: ft({}, this.C), extensions: Array.from(this.h) });
  }
  async writeBinary(t2) {
    const { json: e2, resources: r2 } = await this.writeJSON(t2, { format: v.GLB }), s2 = new Uint32Array([1179937895, 2, 12]), n2 = JSON.stringify(e2), i2 = E.pad(E.encodeText(n2), 32), o2 = E.toView(new Uint32Array([i2.byteLength, 1313821514])), a2 = E.concat([o2, i2]);
    s2[s2.length - 1] += a2.byteLength;
    const u = Object.values(r2)[0];
    if (!u || !u.byteLength)
      return E.concat([E.toView(s2), a2]);
    const c = E.pad(u, 0), h2 = E.toView(new Uint32Array([c.byteLength, 5130562])), l = E.concat([h2, c]);
    return s2[s2.length - 1] += l.byteLength, E.concat([E.toView(s2), a2, l]);
  }
  detectFormat(t2) {
    return "glb" === ($.isAbsoluteURL(t2) ? $.extension(t2) : N.extension(t2)) ? v.GLB : v.GLTF;
  }
  async U(t2) {
    this.lastReadBytes = 0;
    const e2 = await this.readURI(t2, "text");
    this.lastReadBytes += e2.length;
    const r2 = { json: JSON.parse(e2), resources: {} };
    return await this.D(r2, this.dirname(t2)), this.L(r2), r2;
  }
  async P(t2) {
    const e2 = await this.readURI(t2, "view");
    this.lastReadBytes = e2.byteLength;
    const r2 = this._(e2);
    return await this.D(r2, this.dirname(t2)), this.L(r2), r2;
  }
  async D(t2, e2) {
    var r2 = this;
    const s2 = [...t2.json.images || [], ...t2.json.buffers || []].map(async function(s3) {
      const n2 = s3.uri;
      if (!n2 || n2.match(/data:/))
        return Promise.resolve();
      t2.resources[n2] = await r2.readURI(r2.resolve(e2, n2), "view"), r2.lastReadBytes += t2.resources[n2].byteLength;
    });
    await Promise.all(s2);
  }
  L(t2) {
    function e2(e3) {
      if (e3.uri) {
        if (e3.uri in t2.resources)
          E.assertView(t2.resources[e3.uri]);
        else if (e3.uri.match(/data:/)) {
          const r2 = `__${J()}.${N.extension(e3.uri)}`;
          t2.resources[r2] = E.createBufferFromDataURI(e3.uri), e3.uri = r2;
        }
      }
    }
    (t2.json.images || []).forEach((t3) => {
      if (void 0 === t3.bufferView && void 0 === t3.uri)
        throw new Error("Missing resource URI or buffer view.");
      e2(t3);
    }), (t2.json.buffers || []).forEach(e2);
  }
  j(t2) {
    const { images: e2, buffers: r2 } = t2.json;
    return t2 = { json: ft({}, t2.json), resources: ft({}, t2.resources) }, e2 && (t2.json.images = e2.map((t3) => ft({}, t3))), r2 && (t2.json.buffers = r2.map((t3) => ft({}, t3))), t2;
  }
  _(t2) {
    const e2 = new Uint32Array(t2.buffer, t2.byteOffset, 3);
    if (1179937895 !== e2[0])
      throw new Error("Invalid glTF asset.");
    if (2 !== e2[1])
      throw new Error(`Unsupported glTF binary version, "${e2[1]}".`);
    const r2 = new Uint32Array(t2.buffer, t2.byteOffset + 12, 2);
    if (r2[1] !== It.JSON)
      throw new Error("Missing required GLB JSON chunk.");
    const s2 = r2[0], n2 = E.decodeText(E.toView(t2, 20, s2)), i2 = JSON.parse(n2), o2 = 20 + s2;
    if (t2.byteLength <= o2)
      return { json: i2, resources: {} };
    const a2 = new Uint32Array(t2.buffer, t2.byteOffset + o2, 2);
    if (a2[1] !== It.BIN)
      throw new Error("Expected GLB BIN in second chunk.");
    return { json: i2, resources: { "@glb.bin": E.toView(t2, o2 + 8, a2[0]) } };
  }
};
var Nt = class extends Rt {
  constructor(t2 = null, e2 = $.DEFAULT_INIT) {
    super(), this.k = void 0, this.J = void 0, this.$ = void 0, this.V = void 0, this.q = false, this.k = require_fs().promises, this.J = require_path(), this.$ = t2, this.V = e2;
  }
  setAllowHTTP(t2) {
    if (t2 && !this.$)
      throw new Error("NodeIO requires a Fetch API implementation for HTTP requests.");
    return this.q = t2, this;
  }
  async readURI(t2, e2) {
    if ($.isAbsoluteURL(t2)) {
      if (!this.q || !this.$)
        throw new Error("Network request blocked. Allow HTTP requests explicitly, if needed.");
      const r2 = await this.$(t2, this.V);
      switch (e2) {
        case "view":
          return new Uint8Array(await r2.arrayBuffer());
        case "text":
          return r2.text();
      }
    } else
      switch (e2) {
        case "view":
          return this.k.readFile(t2);
        case "text":
          return this.k.readFile(t2, "utf8");
      }
  }
  resolve(t2, e2) {
    return $.isAbsoluteURL(t2) || $.isAbsoluteURL(e2) ? $.resolve(t2, e2) : this.J.resolve(t2, e2);
  }
  dirname(t2) {
    return $.isAbsoluteURL(t2) ? $.dirname(t2) : this.J.dirname(t2);
  }
  async write(t2, e2) {
    const r2 = !!t2.match(/\.glb$/);
    await (r2 ? this.W(t2, e2) : this.H(t2, e2));
  }
  async H(t2, e2) {
    var r2 = this;
    this.lastWriteBytes = 0;
    const { json: s2, resources: n2 } = await this.writeJSON(e2, { format: v.GLTF, basename: N.basename(t2) }), { k: i2, J: o2 } = this, a2 = o2.dirname(t2), u = JSON.stringify(s2, null, 2);
    this.lastWriteBytes += u.length, await i2.writeFile(t2, u);
    const c = Object.keys(n2).map(async function(t3) {
      if ($.isAbsoluteURL(t3)) {
        if ("bin" === $.extension(t3))
          throw new Error(`Cannot write buffer to path "${t3}".`);
        return;
      }
      const e3 = Buffer.from(n2[t3]);
      await i2.writeFile(o2.join(a2, t3), e3), r2.lastWriteBytes += e3.byteLength;
    });
    await Promise.all(c);
  }
  async W(t2, e2) {
    const r2 = Buffer.from(await this.writeBinary(e2));
    await this.k.writeFile(t2, r2), this.lastWriteBytes = r2.byteLength;
  }
};
var Ot = class extends Rt {
  constructor(t2) {
    super(), this.J = void 0, this.J = t2;
  }
  async readURI(t2, e2) {
    switch (e2) {
      case "view":
        return Deno.readFile(t2);
      case "text":
        return Deno.readTextFile(t2);
    }
  }
  resolve(t2, e2) {
    return this.J.resolve(t2, e2);
  }
  dirname(t2) {
    return this.J.dirname(t2);
  }
};
var Ct = class extends Rt {
  constructor(t2 = $.DEFAULT_INIT) {
    super(), this.V = void 0, this.V = t2;
  }
  async readURI(t2, e2) {
    const r2 = await fetch(t2, this.V);
    switch (e2) {
      case "view":
        return new Uint8Array(await r2.arrayBuffer());
      case "text":
        return r2.text();
    }
  }
  resolve(t2, e2) {
    return $.resolve(t2, e2);
  }
  dirname(t2) {
    return $.dirname(t2);
  }
  detectFormat(t2) {
    return "glb" === $.extension(t2) ? v.GLB : v.GLTF;
  }
};
export {
  Y as Accessor,
  Z as Animation,
  K as AnimationChannel,
  Q as AnimationSampler,
  X as Buffer,
  E as BufferUtils,
  V as COPY_IDENTITY,
  tt as Camera,
  S as ColorUtils,
  Ot as DenoIO,
  wt as Document,
  H as ExtensibleProperty,
  yt as Extension,
  et as ExtensionProperty,
  N as FileUtils,
  v as Format,
  g as GLB_BUFFER,
  s as Graph,
  e as GraphEdge,
  I as ImageUtils,
  F as Logger,
  at as Material,
  B as MathUtils,
  ut as Mesh,
  ct as Node,
  Nt as NodeIO,
  Rt as PlatformIO,
  ht as Primitive,
  lt as PrimitiveTarget,
  W as Property,
  p as PropertyType,
  vt as ReaderContext,
  mt as Root,
  dt as Scene,
  gt as Skin,
  pt as Texture,
  y as TextureChannel,
  rt as TextureInfo,
  d2 as VERSION,
  T as Verbosity,
  m as VertexLayout,
  Ct as WebIO,
  Et as WriterContext,
  x as bounds,
  J as uuid
};
//# sourceMappingURL=@gltf-transform_core.js.map
